#include "Framework/EquationSetData.hh"
#include "Framework/PhysicalChemicalLibrary.hh"

//////////////////////////////////////////////////////////////////////////////

namespace COOLFluiD {

  namespace Numerics {

    namespace FiniteVolume {

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
AUSMPlusUpFlux<UPDATEVAR>::AUSMPlusUpFlux(const std::string& name) :
  AUSMFlux<UPDATEVAR>(name),
  m_fa(0.0),
  m_P5Plus(0.),
  m_P5Minus(0.)
{
  this->addConfigOptionsTo(this);
  m_coeffKu = 0.75;
  this->setParameter("coeffKu",&m_coeffKu);

  m_coeffKp = 0.25;
  this->setParameter("coeffKp",&m_coeffKp);

  m_coeffSigma = 1.0;
  this->setParameter("sigma",&m_coeffSigma);

  m_machInf = 0.;
  this->setParameter("machInf",&m_machInf);

  m_beta = 1./8.;
  this->setParameter("beta",&m_beta);
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
AUSMPlusUpFlux<UPDATEVAR>::~AUSMPlusUpFlux()
{
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::defineConfigOptions(Config::OptionList& options)
{
  options.template addConfigOption< CFreal >
    ("coeffKu","Coefficient for Ku.");
  options.template addConfigOption< CFreal >
    ("coeffKp","Way of computing the pressure.");
  options.template addConfigOption< CFreal >
    ("sigma","Coefficient for sigma.");
  options.template addConfigOption< CFreal >
    ("machInf","Free stream Mach number.");
  options.template addConfigOption< CFreal >
    ("beta"," -1/16 <= beta coefficient <= 1/2.");
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::setup()
{
  using namespace COOLFluiD::Framework;
 
  AUSMFlux<UPDATEVAR>::setup();

  const CFuint nbEqs = PhysicalModelStack::getActive()->getNbEq();
  const CFuint nbDim = PhysicalModelStack::getActive()->getDim();

  m_Cons.resize(nbEqs);
  m_dConsdVar.resize(nbEqs);
  m_dVLdVar.resize(nbDim);
  m_dVRdVar.resize(nbDim);
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::computeMassFlux()
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  
  if (m_machInf <= 0.) {
    cout << "AUSMPlusUpFlux requires machInf > 0.!!: change your input file!!" << endl;
  }
  
  this->computeInterfaceSoundSpeed(); // m_a12
  
  // calculation of the Mach number for the left and the right states
  this->m_mL = this->m_unL/this->m_a12;
  this->m_mR = this->m_unR/this->m_a12;
  const CFreal mL = this->m_mL;
  const CFreal mR = this->m_mR;
  const CFreal mBarSq = (this->m_unL*this->m_unL + this->m_unR*this->m_unR) /
    (2.0*this->m_a12*this->m_a12);

  const CFreal mInf = correctMachInf(this->m_machInf);
  const CFreal mZero = std::sqrt(std::min(1.0, max(mBarSq,  mInf*mInf)));
  cf_assert(mZero <= 1.0);

  m_fa = mZero * (2.0-mZero);
  cf_assert(m_fa > 0.0);
   
  const CFreal M4Plus = (std::abs(mL) >= 1.0) ? 
    this->mach1Plus(mL) :
    this->mach2Plus(mL)*(1.0 - 16.*m_beta*this->mach2Min(mL));
  
  const CFreal M4Minus = (std::abs(mR) >= 1.0) ? 
    this->mach1Min(mR) :
    this->mach2Min(mR)*(1.0 + 16.*m_beta*this->mach2Plus(mR));
  
  const CFreal rhoL = (*this->m_lData)[UPDATEVAR::PTERM::RHO];
  const CFreal rhoR = (*this->m_rData)[UPDATEVAR::PTERM::RHO];
  const CFreal pL = (*this->m_lData)[UPDATEVAR::PTERM::P];
  const CFreal pR = (*this->m_rData)[UPDATEVAR::PTERM::P];
  const CFreal rhoa2 = 0.5*(rhoL + rhoR)*this->m_a12*this->m_a12;
  const CFreal mP = (-this->m_coeffKp/m_fa) * max(1.0 - this->m_coeffSigma*mBarSq, 0.0)*
    (pR-pL)/rhoa2;
  
  // calculation of the Mach number at the interface
  const CFreal m12 = M4Plus + M4Minus + mP;
  // calculation of the mass flux at the interface
  this->m_mflux12 = (m12 > 0.0) ? this->m_a12 * m12 * rhoL : this->m_a12 * m12 * rhoR;
}
      
//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::computePressureFlux()
{
  using namespace std;
  using namespace COOLFluiD::Framework;

  // here in AIAA 2003-4116 there is only "m_fa"
  const CFreal alpha = (3.0/16.0) * (-4.0 + 5.0*m_fa*m_fa);
  const CFreal mL = this->m_mL;
  const CFreal mR = this->m_mR;
  m_P5Plus = (std::abs(mL) >= 1.0) ? 
    this->mach1Plus(mL)/mL :
    this->mach2Plus(mL)*((2.0-mL)-16.*alpha*mL*this->mach2Min(mL));
  
  m_P5Minus = (std::abs(mR) >= 1.0) ? 
    this->mach1Min(mR)/mR :
    this->mach2Min(mR)*((-2.0-mR)+16.*alpha*mR*this->mach2Plus(mR));
  
  const CFreal rhoL = (*this->m_lData)[UPDATEVAR::PTERM::RHO];
  const CFreal rhoR = (*this->m_rData)[UPDATEVAR::PTERM::RHO];
  const CFreal pL   = (*this->m_lData)[UPDATEVAR::PTERM::P];
  const CFreal pR   = (*this->m_rData)[UPDATEVAR::PTERM::P];
  const CFreal pU   = -this->m_coeffKu * m_P5Plus * m_P5Minus *
    (rhoL + rhoR) * m_fa * this->m_a12*(this->m_unR-this->m_unL);
  
  // calculation of the pressure flux at the interface
  this->m_p12 = m_P5Plus*pL + m_P5Minus*pR + pU;
}
 
//////////////////////////////////////////////////////////////////////////////

template<class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::ComputeMassFluxForJacobian()
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools; //using MathFunctions::sigmoidal and MathFunctions::sign 

  // Getting state value
  const CFreal rhoL = (*this->m_lData)[UPDATEVAR::PTERM::RHO];
  const CFreal rhoR = (*this->m_rData)[UPDATEVAR::PTERM::RHO];
  const CFreal pL   = (*this->m_lData)[UPDATEVAR::PTERM::P];
  const CFreal pR   = (*this->m_rData)[UPDATEVAR::PTERM::P];
  const CFreal beta = m_beta;
  const CFreal Ksig = this->m_coeffSigmoid;
  //Computing specific jacobian terms
  this->computeSoundSpeedForJacobian();

  const CFreal a12 = this->m_a12;
  //----------------------------------------------------------------------------
  // Getting the specific interface Mach Number
  //----------------------------------------------------------------------------

  const CFreal rho12  = 0.5*(rhoL+rhoR);
  this->m_mL          = this->m_unL/this->m_a12;
  this->m_mR          = this->m_unR/this->m_a12;
  const CFreal ML     = this->m_mL;
  const CFreal MR     = this->m_mR;
  const CFreal mBarSq = 0.5*(ML*ML+MR*MR);
  ///---------------------------------------------------------------------------
  /// Getting the specific scalling factor
  ///---------------------------------------------------------------------------

  const CFreal M4Plus = (std::abs(ML) >= 1.0) ? 
    this->mach1Plus(ML) :
    this->mach2Plus(ML)*(1.0 - 16.*beta*this->mach2Min(ML));
  
  const CFreal M4Minus = (std::abs(MR) >= 1.0) ? 
    this->mach1Min(MR) :
    this->mach2Min(MR)*(1.0 + 16.*beta*this->mach2Plus(MR));
  
  const CFreal mP    = (-this->m_coeffKp)* MathFunctions::sigmoid(1.0 - this->m_coeffSigma*mBarSq,0.0,Ksig)*(pR-pL)/(rho12*a12*a12);
  const CFreal M12   =  M4Plus + M4Minus + mP;
  // Interface Mach number computed ---------------------------------------------
  
  const CFreal rhostar = MathFunctions::sigmoid(M12,0.0,Ksig)*rhoL +(1.0-MathFunctions::sigmoid(M12,0.0,Ksig))*rhoR;
  // Interface density computed -------------------------------------------------

  this->m_mflux12 = M12*a12*rhostar;
}

//////////////////////////////////////////////////////////////////////////////

template<class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::UpdateCoeffForJacobian()
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::Common;
  using namespace COOLFluiD::MathTools;

  CFLog(DEBUG_MED,"AUSMPlusUpFlux::UpdateCoeffForJacobian()  START\n");

  const CFuint nbDim  = PhysicalModelStack::getActive()->getDim();
  const CFreal Ksig   = this->m_coeffSigmoid;
  ComputeMassFluxForJacobian();
  const CFreal mdot12 = this->m_mflux12;
  const CFreal sigmoid = MathFunctions::sigmoid(mdot12,0.0,Ksig);

  (this->m_Cons)[0] = 1.;
  CFLog(DEBUG_MAX,"  ## Conservative variable for analytical jacobian \n");
  CFLog(DEBUG_MAX,"  ## Cons = [" << (this->m_Cons)[0] << " ");

  for (CFuint it = 0; it < nbDim ;it++)
  {
    (this->m_Cons)[it+1] =  sigmoid*(*this->m_lData)[UPDATEVAR::PTERM::VX+it] + (1.0-sigmoid)*(*this->m_rData)[UPDATEVAR::PTERM::VX+it];
    CFLog(DEBUG_MAX,(this->m_Cons)[it] << " ");
  }
  (this->m_Cons)[nbDim+1] = sigmoid*(*this->m_lData)[UPDATEVAR::PTERM::H] + (1.0-sigmoid)*(*this->m_rData)[UPDATEVAR::PTERM::H];
  CFLog(DEBUG_MAX,(this->m_Cons)[nbDim+1] << "]\n");
  CFLog(DEBUG_MAX,"AUSMPlusUpFlux::UpdateCoeffForJacobian()  END\n");
}

//////////////////////////////////////////////////////////////////////////////

template<class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dUpdateCoeffdVar()
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::Common;
  using namespace COOLFluiD::MathTools;

  CFLog(DEBUG_MED,"AUSMPlusUpFlux::dUpdateCoeffdVar()  START\n");

  const CFuint nbDim  = PhysicalModelStack::getActive()->getDim();
  const CFreal Ksig   = this->m_coeffSigmoid;
  ComputeMassFluxForJacobian();
  const CFreal mdot12 = this->m_mflux12;
  const CFreal sigmoid = MathFunctions::sigmoid(mdot12,0.0,Ksig);

  (m_dConsdVar)[0] = 0.;

  CFLog(DEBUG_MAX,"  ## Derivative of the conservative variable for analytical Jacobian \n");
  CFLog(DEBUG_MAX,"  ## dConsdVar = [" << (m_dConsdVar)[0] << " ");
  for (CFuint it = 0; it < nbDim ;it++)
  {
    (m_dConsdVar)[it+1] =  sigmoid*(m_dVLdVar[it]) + (1.0-sigmoid)*(m_dVRdVar[it]);
    CFLog(DEBUG_MAX,(m_dConsdVar)[it] << " ");
  }
  (m_dConsdVar)[nbDim+1] = sigmoid*m_dhLdVar + (1.0-sigmoid)*m_dhRdVar;
    CFLog(DEBUG_MAX,(m_dConsdVar)[nbDim+1] << "]\n");

  CFLog(DEBUG_MAX,"  ## derivative of the velocity \n");
  CFLog(DEBUG_MAX,"  ## dVLdVar = [ ");for (CFuint it = 0;it < nbDim;it++){CFLog(DEBUG_MAX,m_dVLdVar[it] << " ");}CFLog(DEBUG_MAX,"]\n");
  CFLog(DEBUG_MAX,"  ## dVRdVar = [ ");for (CFuint it = 0;it < nbDim;it++){CFLog(DEBUG_MAX,m_dVRdVar[it] << " ");}CFLog(DEBUG_MAX,"]\n");

  CFLog(DEBUG_MED,"AUSMPlusUpFlux::dUpdateCoeffdVar()  END\n");
}

/////////////////////////////////////////////////////////////////////////////

template<class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::ComputeFluxDerivativeWithRespectToVariable(CFreal *row,CFuint iVar)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools; //importing MathFunctions::sigmoidal and MathFunctions::sign functions

  // Getting state value
  const CFreal rhoL        = (*this->m_lData)[UPDATEVAR::PTERM::RHO];
  const CFreal rhoR        = (*this->m_rData)[UPDATEVAR::PTERM::RHO];
  const CFreal HL          = (*this->m_lData)[UPDATEVAR::PTERM::H];
  const CFreal HR          = (*this->m_rData)[UPDATEVAR::PTERM::H];
  const CFreal gammaL      = (*this->m_lData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal gammaR      = (*this->m_rData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal pL          = (*this->m_lData)[UPDATEVAR::PTERM::P];
  const CFreal pR          = (*this->m_rData)[UPDATEVAR::PTERM::P];
  const CFreal beta        = m_beta;
  const CFreal qnL         = this->m_unL;
  const CFreal qnR         = this->m_unR;
  const CFreal Ksig        = this->m_coeffSigmoid;
  const RealVector& normal = this->getMethodData().getUnitNormal();
  const CFuint nbDim       = PhysicalModelStack::getActive()->getDim();
  const CFuint nbEq        = PhysicalModelStack::getActive()->getNbEq();
  cf_assert(nbEq==nbDim+2); // Checking that the vector has the right size

 /// For debugging : prints all data previously computed
  CFLog(VERBOSE," AUSMPlusUpFlux::ComputeFluxDerivativeWithRespectToVariable  START \n");
  CFLog(DEBUG_MED,"## DATA ## rhoL "<< rhoL << " ## rhoR "<< rhoR << " ## HL " << HL << " ## HR "<< HR << " ## MachInf "<< m_machInf << " \n");
  CFLog(DEBUG_MED,"        ## gammaL  "<< gammaL << " ## gammaR "<< gammaR << " ## pL " << pL << " ## pR "<< pR <<"\n");
  CFLog(DEBUG_MED,"        ## beta  "<< beta << " ## qnL "<< qnL << " ## qnR " << qnR << " ## Ksig "<< Ksig <<"\n");
  CFLog(DEBUG_MED,"        ## TL " << (*this->m_lData)[UPDATEVAR::PTERM::T] << " ## TR "  << (*this->m_rData)[UPDATEVAR::PTERM::T] << "\n");
  for (CFuint it = 0; it < nbDim;it++)
    CFLog(DEBUG_MED,"## normal[" <<it<<"] " << normal[it] << " ");
  CFLog(DEBUG_MED,"\n");

  const CFreal dqnLdVar  = m_dqnLdVar;
  const CFreal dqnRdVar  = m_dqnRdVar;
  const CFreal dHLdVar   = m_dhLdVar;
  const CFreal dHRdVar   = m_dhRdVar;
  const CFreal drhoLdVar = m_drhoLdVar;
  const CFreal drhoRdVar = m_drhoRdVar;
  const CFreal dpLdVar   = m_dpLdVar;
  const CFreal dpRdVar   = m_dpRdVar;

  //Computing specific jacobian terms
  //specific speed of sound for the jacobian
  this->computeSoundSpeedForJacobian();
  const CFreal a12 = this->m_a12;

  //----------------------------------------------------------------------------
  // Getting the specific interface Mach Number
  //----------------------------------------------------------------------------
  const CFreal rho12  = 0.5*(rhoL + rhoR);
  this->m_mL          = this->m_unL/this->m_a12;
  this->m_mR          = this->m_unR/this->m_a12;
  const CFreal ML     = this->m_mL;
  const CFreal MR     = this->m_mR;
  const CFreal mBarSq = 0.5*(ML*ML + MR*MR);

  ///---------------------------------------------------------------------------
  /// Getting the specific scalling factor
  ///---------------------------------------------------------------------------
  const CFreal mInf  = correctMachInf(this->m_machInf);
  const CFreal mZero = std::sqrt( std::min (1.0, MathFunctions::sigmoid(mBarSq,mInf*mInf,Ksig)*mBarSq 
                          + (1.0-MathFunctions::sigmoid(mBarSq,mInf*mInf,Ksig)*mInf*mInf) ) );
  
  cf_assert(mZero <= 1.0);

  const CFreal fa = mZero * (2.0-mZero);
  /// Scalling factor computed -------------------------------------------------

  const CFreal M4Plus  = (std::abs(ML) >= 1.0) ? this->mach1Plus(ML) : this->mach2Plus(ML)*(1.0 - 16.*beta*this->mach2Min(ML));
  const CFreal M4Minus = (std::abs(MR) >= 1.0) ? this->mach1Min(MR) : this->mach2Min(MR)*(1.0 + 16.*beta*this->mach2Plus(MR));
  const CFreal mP      = -(this->m_coeffKp) * MathFunctions::sigmoid(1.0 - this->m_coeffSigma*mBarSq,0.0,Ksig)*(pR-pL)/(rho12*a12*a12);
    
  const CFreal M12 =  M4Plus + M4Minus + mP;
  // Interface Mach number computed ---------------------------------------------

  const CFreal rhostar = MathFunctions::sigmoid(M12,0.0,Ksig)*rhoL + (1.0-MathFunctions::sigmoid(M12,0.0,Ksig))*rhoR;
  // Interface density computed -------------------------------------------------

  const CFreal mdot12  = M12*a12*rhostar;
  // New pressure flux for consistency
  this->m_mflux12 = mdot12;

  const CFreal drho12dVar   = 0.5*(drhoLdVar+ drhoRdVar);
  const CFreal drhostardVar = MathFunctions::sigmoid(M12,0,Ksig)*drhoLdVar + (1.0 - MathFunctions::sigmoid(M12,0.0,Ksig))*drhoRdVar;
  
  const CFreal aCritL       = std::sqrt(2.0*(gammaL-1.0)/(gammaL+1.0)*HL);
  const CFreal aCritR       = std::sqrt(2.0*(gammaR-1.0)/(gammaR+1.0)*HR);
  
  const CFreal daCritLdVar  = std::sqrt((gammaL-1.0)/(2.0*HL*(gammaL+1.0)))*dHLdVar;
  const CFreal daCritRdVar  = std::sqrt((gammaR-1.0)/(2.0*HR*(gammaR+1.0)))*dHRdVar;
  
  const CFreal asigL        = MathFunctions::sigmoid(aCritL,qnL,Ksig)*aCritL + (1.0 - MathFunctions::sigmoid(aCritL,qnL,Ksig))*qnL;
  const CFreal asigR        = MathFunctions::sigmoid(aCritR,-qnR,Ksig)*aCritR - (1.0 - MathFunctions::sigmoid(aCritR,-qnR,Ksig))*qnR;
  
  const CFreal dasigLdVar   = MathFunctions::sigmoid(aCritL,qnL,Ksig)*daCritLdVar + (1.0 - MathFunctions::sigmoid(aCritL,qnL,Ksig))*dqnLdVar;
  const CFreal dasigRdVar   = MathFunctions::sigmoid(aCritR,-qnR,Ksig)*daCritRdVar - (1.0 - MathFunctions::sigmoid(aCritR,-qnR,Ksig))*dqnRdVar;
  
  const CFreal ahatL        = aCritL*aCritL/std::max(aCritL,qnL); 
  const CFreal ahatR        = aCritR*aCritR/std::max(aCritR,-qnR); 
  
  /// da12dVar ---------------------------------------------
  const CFreal da12dVar     = (1.0 - MathFunctions::sigmoid(ahatL,ahatR,Ksig))
                                *(2.0*aCritL/asigL*daCritLdVar - aCritL*aCritL/(asigL*asigL)*dasigLdVar)
                              + MathFunctions::sigmoid(ahatL,ahatR,Ksig)
                                *(2.0*aCritR/asigR*daCritRdVar - aCritR*aCritR/(asigR*asigR)*dasigRdVar);
  
  const CFreal dMLdVar      = 1.0/a12*dqnLdVar - qnL/(a12*a12)*da12dVar;
  const CFreal dMRdVar      = 1.0/a12*dqnRdVar - qnR/(a12*a12)*da12dVar;
  
  const CFreal dM4PLusdVar  = (std::abs(ML)>=1.0) ? 0.5*(1. + MathFunctions::sign(ML))*dMLdVar : (0.5*(ML+1.) + 4.*beta*ML*(ML*ML-1.))*dMLdVar;
  const CFreal dM4MinusdVar = (std::abs(MR)>=1.0) ? 0.5*(1. - MathFunctions::sign(MR))*dMRdVar : -(0.5*(MR-1.) + 4.*beta*MR*(MR*MR-1.))*dMRdVar;
  
  const CFreal MBarSq       = 0.5*(ML*ML+MR*MR);
  const CFreal MinfSq       = mInf*mInf;
  
  const CFreal dfadVar      = (ML*dMLdVar+MR*dMRdVar) * ((MBarSq > 1.0) ? 0. : MathFunctions::sigmoid(MBarSq,MinfSq,Ksig)*(1.0-std::sqrt(MBarSq))/std::sqrt(MBarSq));
  
  const CFreal dMpdVar      = -(this->m_coeffKp)*MathFunctions::sigmoid(1-(this->m_coeffSigma)*MBarSq,0.,Ksig)*(
                                        (dpRdVar-dpLdVar)/(rho12*a12*a12)
                                        -(pR-pL)/(rho12*rho12*a12*a12)*drho12dVar
                                        -2.0*(pR-pL)/(rho12*a12*a12*a12)*da12dVar);
  /// dM12dVar ---------------------------------------------
  const CFreal dM12dVar    = dM4PLusdVar + dM4MinusdVar + dMpdVar;
  
  const CFreal dmdot12dVar = dM12dVar*a12*rhostar + M12*da12dVar*rhostar + M12*a12*drhostardVar;

 /// For debugging : prints all the variables involved in the derivation
  CFLog(DEBUG_MAX,"## CPT  ## M12 "<< M12 << " ## a12 " << a12 << " ## rhostar " << rhostar << "\n");
  CFLog(DEBUG_MAX,"        ## ML " << ML << " ## dMLdVar " << dMLdVar << "\n");
  CFLog(DEBUG_MAX,"        ## MR " << MR << " ## dMRdVar " << dMRdVar << "\n");
  CFLog(DEBUG_MAX,"        ## dM12dVar "<< dM12dVar << " ## da12dVar " << da12dVar << " ## drhostardVar " << drhostardVar << "\n");
  CFLog(DEBUG_MAX,"        ## dM4PLusdVar "<< dM4PLusdVar << " ## dM4MinusdVar " << dM4MinusdVar << " ## dmpdVar " << dMpdVar << "\n");
  CFLog(DEBUG_MAX,"        ## dqnLdVar " << dqnLdVar << " ## dqnRdVar " << dqnRdVar <<"\n");
  CFLog(DEBUG_MAX,"        ## ahatL "<< ahatL << " ## ahatR "<< ahatR << " ## sigmoid(ahatL,ahatR,Ksig) " << MathFunctions::sigmoid(ahatL,ahatR,Ksig) << "\n");
  CFLog(DEBUG_MAX,"        ## sigmoid(aCritL,qnL,Ksig) " << MathFunctions::sigmoid(aCritL,qnL,Ksig) << "\n");
  CFLog(DEBUG_MAX,"        ## sigmoid(aCritR,-qnR,Ksig) " << MathFunctions::sigmoid(aCritR,-qnR,Ksig) << "\n");
  CFLog(DEBUG_MAX,"        ## aCritL "<< aCritL << " ## daCritLdVar " << daCritLdVar << " ## asigL "<< asigL << " ## dasigLdVar " << dasigLdVar <<"\n");
  CFLog(DEBUG_MAX,"        ## aCritR "<< aCritR << " ## daCritRdVar " << daCritRdVar << " ## asigR "<< asigR << " ## dasigRdVar " << dasigRdVar <<"\n");
  
  const CFreal alpha      = (3.0/16.0) * (-4.0 + 5.0*fa*fa);
  const CFreal dalphadVar = 15.0/8.0*fa*dfadVar;

  const CFreal P5Plus = (std::abs(ML) >= 1.0) ? 
    this->mach1Plus(ML)/ML :
    this->mach2Plus(ML)*((2.0-ML)-16.*alpha*ML*this->mach2Min(ML));
  m_P5Plus = P5Plus;

  const CFreal P5Minus = (std::abs(MR) >= 1.0) ? 
    this->mach1Min(MR)/MR :
    this->mach2Min(MR)*((-2.0-MR)+16.*alpha*MR*this->mach2Plus(MR));
  m_P5Minus = P5Minus;

  // new pressure interface for consistency
  const CFreal pu = 0.5*this->m_coeffKu*P5Plus*P5Minus*rho12*fa*a12*(qnR-qnL);

  this->m_p12 = P5Plus*pL + P5Minus*pR + pu;

  const CFreal dP5PlusdVar = (std::abs(ML) >= 1.0 ) ? 0. :
                            0.5*(10.0*alpha*ML*ML*ML*ML-(1.5+12.0*alpha)*ML*ML+1.5+2.0*alpha)*dMLdVar 
                            + ML*(ML*ML-1)*(ML*ML-1)*dalphadVar;
  const CFreal dP5MinusdVar = (std::abs(MR) >=1.0 ) ? 0. :
                            -0.5*(10.0*alpha*MR*MR*MR*MR-(1.5+12.0*alpha)*MR*MR+1.5+2.0*alpha)*dMRdVar 
                            - MR*(MR*MR-1)*(MR*MR-1)*dalphadVar;

  const CFreal dpudVar = 0.5*this->m_coeffKu*(
                       dP5PlusdVar*P5Minus*rho12*fa*a12*(qnR-qnL)
                      +P5Plus*dP5MinusdVar*rho12*fa*a12*(qnR-qnL)
                      +P5Plus*P5Minus*drho12dVar*fa*a12*(qnR-qnL)
                      +P5Plus*P5Minus*rho12*dfadVar*a12*(qnR-qnL)
                      +P5Plus*P5Minus*rho12*fa*da12dVar*(qnR-qnL)
                      +P5Plus*P5Minus*rho12*fa*da12dVar*(dqnRdVar-dqnLdVar));

  /// dp12dVar ----------------------------------------------
  const CFreal dp12dVar = dP5PlusdVar*pL + P5Plus*dpLdVar + dP5MinusdVar*pR + P5Minus*dpRdVar + dpudVar;

  cf_assert(nbEq==nbDim+2); // Checking that the vector has the right size
  RealVector P12(nbEq); 
  RealVector dP12dVar(nbEq);                        //P12 = (0,p12*nx,...,0);

  dP12dVar[0] = 0.;
  P12[0]=0.;
  CFLog(DEBUG_MAX,"  ## Derivative of the pressure term for analytical Jacobian \n");
  CFLog(DEBUG_MAX,"  ## dP12dVar = [ " << dP12dVar[0] << " ");
  for (CFuint iDim = 0; iDim < nbDim;iDim++)
  {
    dP12dVar[iDim+1] = dp12dVar*normal[iDim];
    P12[iDim+1] = this->m_p12*normal[iDim];
    CFLog(DEBUG_MAX,dP12dVar[iDim] << " ");
  }
  dP12dVar[nbDim+1] = 0.;
  P12[nbDim+1] = 0.;
  CFLog(DEBUG_MAX,dP12dVar[nbDim+1] << "]\n");

  CFLog(DEBUG_MAX,"        ## alpha " << alpha << " ## dalphadVar " << dalphadVar <<"\n");
  CFLog(DEBUG_MAX,"        ## P5Plus " << P5Plus << " ## dP5PlusdVar " << dP5PlusdVar << "\n");
  CFLog(DEBUG_MAX,"        ## P5Minus " << P5Minus  << " ## dP5MinusdVar " << dP5MinusdVar  << "\n");
  CFLog(DEBUG_MAX,"        ## mdot12 " << mdot12  << " ## dmdot12dVar " << dmdot12dVar << "\n");
  CFLog(DEBUG_MAX,"        ## pu " << pu << " ## dpudVar " << dpudVar <<"\n" );

  CFLog(DEBUG_MIN," ## dFdVar() => isPerturb 1, iVar = "<< iVar <<" , flux = [ ");
  for (CFuint it = 0;it < nbEq ; it++)
  {
    CFLog(DEBUG_MIN,mdot12*(this->m_Cons)[it] + P12[it]<< " ");
  }
  CFLog(DEBUG_MIN,"]\n");

  CFLog(DEBUG_MIN," ##              dfluxdVar = [ ");
  for (CFuint it = 0;it < nbEq ; it++)
  {
    row[it] = dmdot12dVar*(this->m_Cons)[it] + mdot12*(m_dConsdVar)[it] + dP12dVar[it];    //Final result
    CFLog(DEBUG_MIN,row[it] << " ");
  }
  CFLog(DEBUG_MIN,"]\n");

  CFLog(VERBOSE," AUSMPlusUpFlux::ComputeFluxDerivativeWithRespectToVariable  END \n");
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dFdP(CFuint side, CFuint iVar, CFreal* row)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools;
  CFLog(VERBOSE,"AUSMPlusUpFlux::dFdP  START\n");  
  CFLog(DEBUG_MED,"  ## side, iVar : " << side << " " << iVar << "\n");
// Update var : (p,u,v,w,T)
// dudp = dvdp = dwdp = 0 => dqndp = 0  
// H = E + p/rho => H = gamma/(gamma-1)Rgas*T/Mmass + V^2/2 => dHdp = 0
// rho = p*M/(R*T) => drhodP = M/(R*T).
  const CFreal Mmass  = getMMass();; //Moleculare mass of the gas
  const CFreal Rgas   = getRgas();   //gas constant
  const CFreal TL     = (*this->m_lData)[UPDATEVAR::PTERM::T];
  const CFreal TR     = (*this->m_rData)[UPDATEVAR::PTERM::T];
  
  m_dqnLdVar  = 0.;
  m_dqnRdVar  = 0.;
  m_dhLdVar   = 0.;
  m_dhRdVar   = 0.;
  m_drhoLdVar = (side == LEFT) ? Mmass/(Rgas*TL) : 0.;
  m_drhoRdVar = (side == LEFT) ? 0. : Mmass/(Rgas*TR);
  m_dpLdVar   = (side == LEFT) ? 1. : 0.;
  m_dpRdVar   = (side == LEFT) ? 0. : 1.;

  const CFuint nbDim  = PhysicalModelStack::getActive()->getDim();
  for (CFuint it = 0; it < nbDim ;it++)
    {
      m_dVLdVar[it]   = 0.;
      m_dVRdVar[it]   = 0.;
    }

  UpdateCoeffForJacobian();
  dUpdateCoeffdVar();
  ComputeFluxDerivativeWithRespectToVariable(row,iVar);
}
 
//////////////////////////////////////////////////////////////////////////////
   
template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dFdT(CFuint side, CFuint iVar, CFreal* row)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools;
  CFLog(VERBOSE,"AUSMPlusUpFlux::dFdT  START\n");  
  CFLog(DEBUG_MED,"  ## side, iVar : " << side << " " << iVar << "\n");
// Update var : (p,u,v,w,T)
// dudT = dvdT = dwdT = 0 => dqndT = 0  
// H = E + p/rho => H = gamma/(gamma-1)Rgas*T/Mmass + V^2/2 => dHdT = gamma/(gamma-1)Rgas*/Mmass
// rho = p*M/(R*T) => drhodT = -M*p/(R*T^2).
  const CFreal Mmass     = getMMass(); //Moleculare mass of the gas
  const CFreal Rgas      = getRgas();  //gas constant
  const CFreal pL        = (*this->m_lData)[UPDATEVAR::PTERM::P];
  const CFreal pR        = (*this->m_rData)[UPDATEVAR::PTERM::P];
  const CFreal TL        = (*this->m_lData)[UPDATEVAR::PTERM::T];
  const CFreal TR        = (*this->m_rData)[UPDATEVAR::PTERM::T];
  const CFreal gammaL    = (*this->m_lData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal gammaR    = (*this->m_rData)[UPDATEVAR::PTERM::GAMMA];

  m_dqnLdVar  = 0.;
  m_dqnRdVar  = 0.;
  m_dhLdVar   = (side == LEFT) ? gammaL*Rgas/(Mmass*(gammaL-1.)) : 0.;
  m_dhRdVar   = (side == LEFT) ? 0. : gammaR*Rgas/(Mmass*(gammaR-1.));
  m_drhoLdVar = (side == LEFT) ? -Mmass*pL/(Rgas*TL*TL) : 0.;
  m_drhoRdVar = (side == LEFT) ? 0. : -Mmass*pR/(Rgas*TR*TR);
  m_dpLdVar   = 0.;
  m_dpRdVar   = 0.;

  const CFuint nbDim  = PhysicalModelStack::getActive()->getDim();
  for (CFuint it = 0; it < nbDim ;it++)
    {
      m_dVLdVar[it]   = 0.;
      m_dVRdVar[it]   = 0.;
    }

  UpdateCoeffForJacobian();
  dUpdateCoeffdVar();
  ComputeFluxDerivativeWithRespectToVariable(row,iVar);
  CFLog(VERBOSE,"AUSMPlusUpFlux::dFdT  END\n");  
}

//////////////////////////////////////////////////////////////////////////////
   
template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dFdU(CFuint side, CFuint iVar, CFreal* row)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools;
  CFLog(VERBOSE,"AUSMPlusUpFlux::dFdU  START\n");  
  CFLog(DEBUG_MED,"  ## side, iVar : " << side << " " << iVar << "\n");
// Update var : (p,u,v,w,T)
// dudu= 1.; dvdu = dwdu = 0 => dqndu = nx  
// H = E + p/rho => H = R*T*gamma/(M*(gamma-1) + V^2/2 => dHdu = u
// rho = p*M/(R*T) => drhodu =0.
  const RealVector& normal = this->getMethodData().getUnitNormal();
  m_dqnLdVar  = (side == LEFT) ? normal[0] : 0.;
  m_dqnRdVar  = (side == LEFT) ? 0. : normal[0];
  m_dhLdVar   = (side == LEFT) ?(*this->m_lData)[UPDATEVAR::PTERM::VX]: 0.;
  m_dhRdVar   = (side == LEFT) ? 0. : (*this->m_rData)[UPDATEVAR::PTERM::VX];
  m_drhoLdVar = 0.;
  m_drhoRdVar = 0.;
  m_dpLdVar   = 0.;
  m_dpRdVar   = 0.;

  const CFuint nbDim  = PhysicalModelStack::getActive()->getDim();
  for (CFuint it = 0; it < nbDim ;it++)
    {
      m_dVLdVar[it]   = 0.;
      m_dVRdVar[it]   = 0.;
    }
  m_dVLdVar[0]   = (side == LEFT) ? 1. : 0.;
  m_dVRdVar[0]   = (side == LEFT) ? 0. : 1.;

  UpdateCoeffForJacobian();
  dUpdateCoeffdVar();
  ComputeFluxDerivativeWithRespectToVariable(row,iVar);
  CFLog(VERBOSE,"AUSMPlusUpFlux::dFdU  END\n");  
}

//////////////////////////////////////////////////////////////////////////////
   
template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dFdV(CFuint side, CFuint iVar, CFreal* row)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools;
  CFLog(VERBOSE,"AUSMPlusUpFlux::dFdV  START\n");  
  CFLog(DEBUG_MED,"  ## side, iVar : " << side << " " << iVar << "\n");
// Update var : (p,u,v,w,T)
// dvdv= 1.; dudv = dwdv = 0 => dqndv = ny  
// H = E + p/rho => H = R*T*gamma/(M*(gamma-1) + V^2/2 => dHdv = v
// rho = p*M/(R*T) => drhodu =0.

  const RealVector& normal = this->getMethodData().getUnitNormal();

  m_dqnLdVar  = (side == LEFT) ? normal[1] : 0.;
  m_dqnRdVar  = (side == LEFT) ? 0. : normal[1];
  m_dhLdVar   = (side == LEFT) ?(*this->m_lData)[UPDATEVAR::PTERM::VY]: 0.;
  m_dhRdVar   = (side == LEFT) ? 0. : (*this->m_rData)[UPDATEVAR::PTERM::VY];
  m_drhoLdVar = 0.;
  m_drhoRdVar = 0.;
  m_dpLdVar   = 0.;
  m_dpRdVar   = 0.;

  const CFuint nbDim  = PhysicalModelStack::getActive()->getDim();
  for (CFuint it = 0; it < nbDim ;it++)
    {
      m_dVLdVar[it]   = 0.;
      m_dVRdVar[it]   = 0.;
    }
  m_dVLdVar[1]   = (side == LEFT) ? 1. : 0.;
  m_dVRdVar[1]   = (side == LEFT) ? 0. : 1.;

  UpdateCoeffForJacobian();
  dUpdateCoeffdVar();
  ComputeFluxDerivativeWithRespectToVariable(row,iVar);
  CFLog(VERBOSE,"AUSMPlusUpFlux::dFdV  END\n");  

}

//////////////////////////////////////////////////////////////////////////////
  
template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dFdW(CFuint side, CFuint iVar, CFreal* row)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools;
  CFLog(VERBOSE,"AUSMPlusUpFlux::dFdW  START\n");  
  CFLog(DEBUG_MED,"  ## side, iVar : " << side << " " << iVar << "\n");
// Update var : (p,u,v,w,T)
// dwdw= 1.; dudw = dvdw = 0 => dqndw = nz  
// H = E + p/rho => H = R*T*gamma/(M*(gamma-1) + V^2/2 => dHdv = w
// rho = p*M/(R*T) => drhodu =0.
  const RealVector& normal = this->getMethodData().getUnitNormal();

  m_dqnLdVar  = (side == LEFT) ? normal[2] : 0.;
  m_dqnRdVar  = (side == LEFT) ? 0. : normal[2];
  m_dhLdVar   = (side == LEFT) ?(*this->m_lData)[UPDATEVAR::PTERM::VZ]: 0.;
  m_dhRdVar   = (side == LEFT) ? 0. : (*this->m_rData)[UPDATEVAR::PTERM::VZ];
  m_drhoLdVar = 0.;
  m_drhoRdVar = 0.;
  m_dpLdVar   = 0.;
  m_dpRdVar   = 0.;

  const CFuint nbDim  = PhysicalModelStack::getActive()->getDim();
  for (CFuint it = 0; it < nbDim ;it++)
    {
      m_dVLdVar[it]   = 0.;
      m_dVRdVar[it]   = 0.;
    }
  m_dVLdVar[2]   = (side == LEFT) ? 1. : 0.;
  m_dVRdVar[2]   = (side == LEFT) ? 0. : 1.;

  UpdateCoeffForJacobian();
  dUpdateCoeffdVar();
  ComputeFluxDerivativeWithRespectToVariable(row,iVar);
  CFLog(VERBOSE,"AUSMPlusUpFlux::dFdW  END\n");  
}
 
//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dFdK(CFuint side, CFuint iVar, CFreal* row)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools;
  CFLog(VERBOSE,"AUSMPlusUpFlux::dFdK  START\n");  
  CFLog(DEBUG_MED,"  ## side, iVar : " << side << " " << iVar << "\n");
// Update var : ???
  m_dqnLdVar  = 0.;
  m_dqnRdVar  = 0.;
  m_dhLdVar   = 0.;
  m_dhRdVar   = 0.;
  m_drhoLdVar = 0.;
  m_drhoRdVar = 0.;
  m_dpLdVar   = 0.;
  m_dpRdVar   = 0.;

  const CFuint nbDim  = PhysicalModelStack::getActive()->getDim();
  for (CFuint it = 0; it < nbDim ;it++)
    {
      m_dVLdVar[it]   = 0.;
      m_dVRdVar[it]   = 0.;
    }

  UpdateCoeffForJacobian();
  dUpdateCoeffdVar();
  ComputeFluxDerivativeWithRespectToVariable(row,iVar);
  CFLog(VERBOSE,"AUSMPlusUpFlux::dFdK  END\n");  
}
 
//////////////////////////////////////////////////////////////////////////////
      
template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dFdRho(CFuint side, CFuint iVar, CFreal* row)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools;	
  CFLog(VERBOSE,"AUSMPlusUpFlux::dFdRho  START\n");  
	CFLog(DEBUG_MED,"  ## side, iVar : " << side << " " << iVar << "\n");
// Update var : (rho,rhou,rhov,rhow,rhoE)
// E        = p/(rho*gamma-1) + V^2/2 => 
// p        = (gamma -1 )(rhoE - 0.5(rhoV)^2/rho) 
// dpdrho    = 0.5(gamma -1)V^2;
// u        = rhou/rho  
// dudrho   = -rhou/rho^2 
// dqndrho = -(unx+vny+wnz)/rho = -qn/rho
// H        = E + p/rho => 
// H        = gamma*rhoE/rho - 0.5*(gamma-1)*(rhoV)^2/rho^2 
// dHdrho   = -gamma*rhoE/rho^2 +(gamma-1)(rhou^2+rhov^2+rhow^2)/rho^3
  const CFreal gammaL    = (*this->m_lData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal gammaR    = (*this->m_rData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal rhoL      = (*this->m_lData)[UPDATEVAR::PTERM::RHO];
  const CFreal rhoR      = (*this->m_rData)[UPDATEVAR::PTERM::RHO];
  const CFreal EL        = (*this->m_lData)[UPDATEVAR::PTERM::E];
  const CFreal ER        = (*this->m_rData)[UPDATEVAR::PTERM::E];
  const CFreal qnL       = this->m_unL;
  const CFreal qnR       = this->m_unR;
  
  m_dqnLdVar  = (side == LEFT) ? -qnL/rhoL : 0.;
  m_dqnRdVar  = (side == LEFT) ? 0. : -qnR/rhoR;

  const CFuint nbDim  = PhysicalModelStack::getActive()->getDim();

  CFreal VLsq = 0.;
  CFreal VRsq = 0.;
  for (CFuint it = 0; it < nbDim ;it++)
    {
      VLsq = VLsq + (*this->m_lData)[UPDATEVAR::PTERM::VX+it]*(*this->m_lData)[UPDATEVAR::PTERM::VX+it]; // 2D : uL*uL+vL*vL  3D : uL*uL+vL*vL+wL*wL
      VRsq = VRsq + (*this->m_rData)[UPDATEVAR::PTERM::VX+it]*(*this->m_rData)[UPDATEVAR::PTERM::VX+it]; // 2D : uR*uR+vR*vR  3D : uR*uR+vR*vR+wR*wR
    }
  m_dhLdVar   = (side == LEFT) ? -gammaL*EL/rhoL + (gammaL-1.)*VLsq/rhoL : 0.;
  m_dhRdVar   = (side == LEFT) ? 0. :-gammaR*ER/rhoR + (gammaR-1.)*VRsq/rhoR;
  m_drhoLdVar = (side == LEFT) ? 1. : 0.;
  m_drhoRdVar = (side == LEFT) ? 0. : 1.;
  m_dpLdVar   = (side == LEFT) ? 0.5*(gammaL-1.)*VLsq : 0.;
  m_dpRdVar   = (side == LEFT) ? 0. : 0.5*(gammaR-1.)*VRsq;

  for (CFuint it = 0; it < nbDim ;it++)
    {
      m_dVLdVar[it]   = (side == LEFT) ? -(*this->m_lData)[UPDATEVAR::PTERM::VX+it]/rhoL : 0.;
      m_dVRdVar[it]   = (side == LEFT) ? 0. : -(*this->m_rData)[UPDATEVAR::PTERM::VX+it]/rhoR;
    }

  UpdateCoeffForJacobian();
  dUpdateCoeffdVar();
  ComputeFluxDerivativeWithRespectToVariable(row,iVar);

  CFLog(VERBOSE,"AUSMPlusUpFlux::dFdRho  END\n");  

}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dFdRhoU(CFuint side, CFuint iVar, CFreal* row)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools;
  CFLog(VERBOSE,"AUSMPlusUpFlux::dFdRhoU  START\n");  
  CFLog(DEBUG_MED,"  ## side, iVar : " << side << " " << iVar << "\n");
// Update var : (rho,rhou,rhov,rhow,rhoE)
// E = p/(rho*gamma-1) + V^2/2  
// p = (gamma -1 )(rhoE - 0.5(rhoV)^2/rho) 
// dprhou = -(gamma -1)u;
// u = rhou/rho => dwdrhou = 1/rho => dqndrhou = nx/rho
// H = E + p/rho
// H = gamma*rhoE/rho - 0.5*(gamma-1)*(rhoV)^2/rho^2 
// dHdrhou = -(gamma-1)u/rho;
  const RealVector& normal = this->getMethodData().getUnitNormal();
  const CFreal rhoL        = (*this->m_lData)[UPDATEVAR::PTERM::RHO];
  const CFreal rhoR        = (*this->m_rData)[UPDATEVAR::PTERM::RHO];
  const CFreal uL          = (*this->m_lData)[UPDATEVAR::PTERM::VX];
  const CFreal uR          = (*this->m_rData)[UPDATEVAR::PTERM::VX];
  const CFreal gammaL      = (*this->m_lData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal gammaR      = (*this->m_rData)[UPDATEVAR::PTERM::GAMMA];

  m_dqnLdVar  = (side == LEFT) ? normal[0]/rhoL: 0.;
  m_dqnRdVar  = (side == LEFT) ? 0. : normal[0]/rhoR;
  m_dhLdVar   = (side == LEFT) ? -(gammaL-1.)*uL/rhoL: 0.;
  m_dhRdVar   = (side == LEFT) ? 0 : -(gammaR-1.)*uR/rhoR;
  m_drhoLdVar = 0.;
  m_drhoRdVar = 0.;
  m_dpLdVar   = (side == LEFT) ? -(gammaL-1.)*uL: 0.;
  m_dpRdVar   = (side == LEFT) ? 0. : -(gammaR-1.)*uR;

  const CFuint nbDim  = PhysicalModelStack::getActive()->getDim();
  for (CFuint it = 0; it < nbDim ;it++)
    {
      m_dVLdVar[it]   = 0.;
      m_dVRdVar[it]   = 0.;
    }
  m_dVLdVar[0]   = (side == LEFT) ? 1/rhoL : 0.;
  m_dVRdVar[0]   = (side == LEFT) ? 0. : 1/rhoR;

  UpdateCoeffForJacobian();
  dUpdateCoeffdVar();
  ComputeFluxDerivativeWithRespectToVariable(row,iVar);
  CFLog(VERBOSE,"AUSMPlusUpFlux::dFdRhoU  END\n");  
}
 
//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dFdRhoV(CFuint side, CFuint iVar, CFreal* row)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools;
  CFLog(VERBOSE,"AUSMPlusUpFlux::dFdRhoV  START\n");  
  CFLog(DEBUG_MED,"  ## side, iVar : " << side << " " << iVar << "\n");
// Update var : (rho,rhou,rhov,rhow,rhoE)
// E = p/(rho*gamma-1) + V^2/2 => p = (gamma -1 )(rhoE - 0.5(rhoV)^2/rho^2) => dprhov = -(gamma -1)v/rho;
// v = rhov/rho => dwdrhoc = 1/rho => dqndrhov = ny/rho
// H = E + p/rho => H = gamma*rhoE/rho - 0.5*(gamma-1)*(rhoV)^2/rho^2 => dHdrhov = -(gamma-1)v/rho
  const RealVector& normal = this->getMethodData().getUnitNormal();
  const CFreal rhoL        = (*this->m_lData)[UPDATEVAR::PTERM::RHO];
  const CFreal rhoR        = (*this->m_rData)[UPDATEVAR::PTERM::RHO];
  const CFreal vL          = (*this->m_lData)[UPDATEVAR::PTERM::VY];
  const CFreal vR          = (*this->m_rData)[UPDATEVAR::PTERM::VY];
  const CFreal gammaL      = (*this->m_lData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal gammaR      = (*this->m_rData)[UPDATEVAR::PTERM::GAMMA];
  
  m_dqnLdVar  = (side == LEFT) ? normal[1]/rhoL: 0.;
  m_dqnRdVar  = (side == LEFT) ? 0. : normal[1]/rhoR;
  m_dhLdVar   = (side == LEFT) ? -(gammaL-1.)*vL/rhoL: 0.;
  m_dhRdVar   = (side == LEFT) ? 0 : -(gammaR-1.)*vR/rhoR;
  m_drhoLdVar = 0.;
  m_drhoRdVar = 0.;
  m_dpLdVar   = (side == LEFT) ? -(gammaL-1.)*vL: 0.;
  m_dpRdVar   = (side == LEFT) ? 0. : -(gammaR-1.)*vR;

  const CFuint nbDim  = PhysicalModelStack::getActive()->getDim();
  for (CFuint it = 0; it < nbDim ;it++)
    {
      m_dVLdVar[it]   = 0.;
      m_dVRdVar[it]   = 0.;
    }
  m_dVLdVar[1]   = (side == LEFT) ? 1/rhoL : 0.;
  m_dVRdVar[1]   = (side == LEFT) ? 0. : 1/rhoR;

  UpdateCoeffForJacobian();
  dUpdateCoeffdVar();
  ComputeFluxDerivativeWithRespectToVariable(row,iVar);
  CFLog(VERBOSE,"AUSMPlusUpFlux::dFdRhoV  END\n");  

}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dFdRhoW(CFuint side, CFuint iVar, CFreal* row)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools; 
  CFLog(VERBOSE,"AUSMPlusUpFlux::dFdRhoW  START\n");  
  CFLog(DEBUG_MED,"  ## side, iVar : " << side << " " << iVar << "\n");
// Update var : (rho,rhou,rhov,rhow,rhoE)
// E = p/(rho*gamma-1) + V^2/2 => p = (gamma -1 )(rhoE - 0.5(rhoV)^2/rho^2) => dprhow = -(gamma -1)w/rho;
// w = rhoW/rho => dwdrhoW = 1/rho => dqndrhoW = nz/rho
// H = E + p/rho =
// H = gamma*rhoE/rho - 0.5*(gamma-1)*(rhoV)^2/rho^2 
// dHdrhow = -(gamma-1)w/rho
  const RealVector& normal = this->getMethodData().getUnitNormal();
  const CFreal rhoL        = (*this->m_lData)[UPDATEVAR::PTERM::RHO];
  const CFreal rhoR        = (*this->m_rData)[UPDATEVAR::PTERM::RHO];
  const CFreal wL          = (*this->m_lData)[UPDATEVAR::PTERM::VZ];
  const CFreal wR          = (*this->m_rData)[UPDATEVAR::PTERM::VZ];
  const CFreal gammaL      = (*this->m_lData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal gammaR      = (*this->m_rData)[UPDATEVAR::PTERM::GAMMA];
  
  m_dqnLdVar  = (side == LEFT) ? normal[2]/rhoL: 0.;
  m_dqnRdVar  = (side == LEFT) ? 0. : normal[2]/rhoR;
  m_dhLdVar   = (side == LEFT) ? -(gammaL-1.)*wL/rhoL: 0.;
  m_dhRdVar   = (side == LEFT) ? 0 : -(gammaR-1.)*wR/rhoR;
  m_drhoLdVar = 0.;
  m_drhoRdVar = 0.;
  m_dpLdVar   = (side == LEFT) ? -(gammaL-1.)*wL: 0.;
  m_dpRdVar   = (side == LEFT) ? 0. : -(gammaR-1.)*wR;

  const CFuint nbDim  = PhysicalModelStack::getActive()->getDim();
  for (CFuint it = 0; it < nbDim ;it++)
    {
      m_dVLdVar[it]   = 0.;
      m_dVRdVar[it]   = 0.;
    }
  m_dVLdVar[2]   = (side == LEFT) ? 1/rhoL : 0.;
  m_dVRdVar[2]   = (side == LEFT) ? 0. : 1/rhoR;

  UpdateCoeffForJacobian();
  dUpdateCoeffdVar();
  ComputeFluxDerivativeWithRespectToVariable(row,iVar);
  CFLog(VERBOSE,"AUSMPlusUpFlux::dFdRhoW  END\n");  
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dFdRhoE(CFuint side, CFuint iVar, CFreal* row)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools;
  CFLog(VERBOSE,"AUSMPlusUpFlux::dFdRhoE  START\n");  
  CFLog(DEBUG_MED,"  ## side, iVar : " << side << " " << iVar << "\n");
  const CFreal rhoL = (*this->m_lData)[UPDATEVAR::PTERM::RHO];
  const CFreal rhoR = (*this->m_rData)[UPDATEVAR::PTERM::RHO];
  const CFreal gammaL = (*this->m_lData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal gammaR = (*this->m_rData)[UPDATEVAR::PTERM::GAMMA];
// Update var : (rho,rhou,rhov,rhow,rhoE)
// E = p/(rho*gamma-1) + V^2/2 
// p = (gamma -1 )(rhoE - 0.5(rhoV)^2/rho) 
// dprhoE = gamma-1;
// u = rhou/rho 
// dudrhoE = 0. 
// dqndrhoE = 0
// H = E + p/rho 
// H = gamma*rhoE/rho - 0.5*(gamma-1)*(rhoV)^2/rho^2 
// dHdrhoE = gamma/rho .
  m_dqnLdVar  = 0.;
  m_dqnRdVar  = 0.;
  m_dhLdVar   = (side == LEFT) ? gammaL/rhoL : 0.;
  m_dhRdVar   = (side == LEFT) ? 0. : gammaR/rhoR;
  m_drhoLdVar = 0.;
  m_drhoRdVar = 0.;
  m_dpLdVar   = (side == LEFT) ? gammaL-1. : 0.;
  m_dpRdVar   = (side == LEFT) ? 0. : gammaR-1.;

  const CFuint nbDim  = PhysicalModelStack::getActive()->getDim();
  for (CFuint it = 0; it < nbDim ;it++)
    {
      m_dVLdVar[it]   = 0.;
      m_dVRdVar[it]   = 0.;
    }

  UpdateCoeffForJacobian();
  dUpdateCoeffdVar();
  ComputeFluxDerivativeWithRespectToVariable(row,iVar);
  CFLog(VERBOSE,"AUSMPlusUpFlux::dFdRhoE  END\n");  
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
CFreal AUSMPlusUpFlux<UPDATEVAR>::getRgas()
{
  CFreal Rgas;
  Rgas = 8.3145; //[J/mol/K] taken from wolfram alpha
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::getRgas() => Rgas = "<< Rgas <<"\n");
  return Rgas;
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
CFreal AUSMPlusUpFlux<UPDATEVAR>::getMMass()
{
  CFreal MMass;
  MMass = 28.965338E-3; //Assuming current fluid is air
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::getMMass() => Mmass = "<< MMass<<"\n");
  return MMass;
}

//////////////////////////////////////////////////////////////////////////////

    } // namespace FiniteVolume

  } // namespace Numerics

} // namespace COOLFluiD

//////////////////////////////////////////////////////////////////////////////
