#include "Framework/EquationSetData.hh"
#include "Framework/PhysicalChemicalLibrary.hh"

//////////////////////////////////////////////////////////////////////////////

namespace COOLFluiD {

  namespace Numerics {

    namespace FiniteVolume {

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
AUSMPlusUpFlux<UPDATEVAR>::AUSMPlusUpFlux(const std::string& name) :
  AUSMFlux<UPDATEVAR>(name),
  m_fa(0.0),
  m_P5Plus(0.),
  m_P5Minus(0.)
{
  this->addConfigOptionsTo(this);
  m_coeffKu = 0.75;
  this->setParameter("coeffKu",&m_coeffKu);

  m_coeffKp = 0.25;
  this->setParameter("coeffKp",&m_coeffKp);

  m_coeffSigma = 1.0;
  this->setParameter("sigma",&m_coeffSigma);

  m_machInf = 0.;
  this->setParameter("machInf",&m_machInf);

  m_beta = 1./8.;
  this->setParameter("beta",&m_beta);
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
AUSMPlusUpFlux<UPDATEVAR>::~AUSMPlusUpFlux()
{
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::defineConfigOptions(Config::OptionList& options)
{
  options.template addConfigOption< CFreal >
    ("coeffKu","Coefficient for Ku.");
  options.template addConfigOption< CFreal >
    ("coeffKp","Way of computing the pressure.");
  options.template addConfigOption< CFreal >
    ("sigma","Coefficient for sigma.");
  options.template addConfigOption< CFreal >
    ("machInf","Free stream Mach number.");
  options.template addConfigOption< CFreal >
    ("beta"," -1/16 <= beta coefficient <= 1/2.");
}

//////////////////////////////////////////////////////////////////////////////

// template <class UPDATEVAR>
// void AUSMPlusUpFlux<UPDATEVAR>::setup()
// {
//   using namespace COOLFluiD::Framework;
 
//   AUSMFlux<UPDATEVAR>::setup();

//   const CFuint nbDim = PhysicalModelStack::getActive()->getDim();
//   m_dVLdVar.resize(nbDim);
//  m_dVRdVar.resize(nbDim);
// }

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::computeMassFlux()
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  
  if (m_machInf <= 0.) {
    cout << "AUSMPlusUpFlux requires machInf > 0.!!: change your input file!!" << endl;
  }
  
  this->computeInterfaceSoundSpeed(); // m_a12
  
  // calculation of the Mach number for the left and the right states
  this->m_mL = this->m_unL/this->m_a12;
  this->m_mR = this->m_unR/this->m_a12;
  const CFreal mL = this->m_mL;
  const CFreal mR = this->m_mR;
  const CFreal mBarSq = (this->m_unL*this->m_unL + this->m_unR*this->m_unR) / (2.0*this->m_a12*this->m_a12);

  const CFreal mInf = correctMachInf(this->m_machInf);
  const CFreal mZero = std::sqrt(std::min(1.0, max(mBarSq,  mInf*mInf)));
  cf_assert(mZero <= 1.0);

  m_fa = mZero * (2.0-mZero);
  cf_assert(m_fa > 0.0);
   
  const CFreal M4Plus = (std::abs(mL) >= 1.0) ? 
    this->mach1Plus(mL) :
    this->mach2Plus(mL)*(1.0 - 16.*m_beta*this->mach2Min(mL));
  
  const CFreal M4Minus = (std::abs(mR) >= 1.0) ? 
    this->mach1Min(mR) :
    this->mach2Min(mR)*(1.0 + 16.*m_beta*this->mach2Plus(mR));
  
  const CFreal rhoL = (*this->m_lData)[UPDATEVAR::PTERM::RHO];
  const CFreal rhoR = (*this->m_rData)[UPDATEVAR::PTERM::RHO];
  const CFreal pL = (*this->m_lData)[UPDATEVAR::PTERM::P];
  const CFreal pR = (*this->m_rData)[UPDATEVAR::PTERM::P];
  const CFreal rhoa2 = 0.5*(rhoL + rhoR)*this->m_a12*this->m_a12;
  const CFreal mP = (-this->m_coeffKp/m_fa) * max(1.0 - this->m_coeffSigma*mBarSq, 0.0)*(pR-pL)/rhoa2;
  
  // calculation of the Mach number at the interface
  const CFreal m12 = M4Plus + M4Minus + mP;
  // calculation of the mass flux at the interface
  this->m_mflux12 = (m12 > 0.0) ? this->m_a12 * m12 * rhoL : this->m_a12 * m12 * rhoR;
}
      
//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::computePressureFlux()
{
  using namespace std;
  using namespace COOLFluiD::Framework;

  // here in AIAA 2003-4116 there is only "m_fa"
  const CFreal alpha = (3.0/16.0) * (-4.0 + 5.0*m_fa*m_fa);
  const CFreal mL = this->m_mL;
  const CFreal mR = this->m_mR;
  m_P5Plus = (std::abs(mL) >= 1.0) ? 
    this->mach1Plus(mL)/mL :
    this->mach2Plus(mL)*((2.0-mL)-16.*alpha*mL*this->mach2Min(mL));
  
  m_P5Minus = (std::abs(mR) >= 1.0) ? 
    this->mach1Min(mR)/mR :
    this->mach2Min(mR)*((-2.0-mR)+16.*alpha*mR*this->mach2Plus(mR));
  
  const CFreal rhoL = (*this->m_lData)[UPDATEVAR::PTERM::RHO];
  const CFreal rhoR = (*this->m_rData)[UPDATEVAR::PTERM::RHO];
  const CFreal pL   = (*this->m_lData)[UPDATEVAR::PTERM::P];
  const CFreal pR   = (*this->m_rData)[UPDATEVAR::PTERM::P];
  const CFreal pU   = -this->m_coeffKu * m_P5Plus * m_P5Minus *
    (rhoL + rhoR) * m_fa * this->m_a12*(this->m_unR-this->m_unL);
  
  // calculation of the pressure flux at the interface
  this->m_p12 = m_P5Plus*pL + m_P5Minus*pR + pU;
}
 
/////////////////////////////////////////////////////////////////////////////

template<class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::ComputedFluxdVar(CFuint iVar, RealMatrix& JacobMatrix)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools; //importing MathFunctions::sigmoidal and MathFunctions::sign functions
  CFLog(VERBOSE," AUSMPlusUpFlux::ComputedFluxdVar  START \n");

  // Getting state value
  const CFreal rhoL        = (*this->m_lData)[UPDATEVAR::PTERM::RHO];
  const CFreal rhoR        = (*this->m_rData)[UPDATEVAR::PTERM::RHO];
  const CFreal HL          = (*this->m_lData)[UPDATEVAR::PTERM::H];
  const CFreal HR          = (*this->m_rData)[UPDATEVAR::PTERM::H];
  const CFreal gammaL      = (*this->m_lData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal gammaR      = (*this->m_rData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal pL          = (*this->m_lData)[UPDATEVAR::PTERM::P];
  const CFreal pR          = (*this->m_rData)[UPDATEVAR::PTERM::P];
  const CFreal beta        = m_beta;
  const CFreal qnL         = this->m_unL;
  const CFreal qnR         = this->m_unR;
  const CFreal Ksig        = this->m_coeffSigmoid;
  const RealVector& normal = this->getMethodData().getUnitNormal();
  const CFuint nbDim       = PhysicalModelStack::getActive()->getDim();
  const CFuint nbEq        = PhysicalModelStack::getActive()->getNbEq();
  cf_assert(nbEq==nbDim+2); // Checking that the vector has the right size

  this->computeSoundSpeedForJacobian();
  const CFreal a12 = this->m_a12;

  const CFreal rho12  = 0.5*(rhoL + rhoR);
  this->m_mL          = this->m_unL/this->m_a12;
  this->m_mR          = this->m_unR/this->m_a12;
  const CFreal ML     = this->m_mL;
  const CFreal MR     = this->m_mR;

  const CFreal mInf            = correctMachInf(this->m_machInf);
  const CFreal MBarSq          = 0.5*(ML*ML+MR*MR);
  const CFreal MinfSq          = mInf*mInf;
  const CFreal sigMbarsqMinfsq = MathFunctions::sigmoid(MBarSq,MinfSq,Ksig);
  const CFreal sig2            = sigMbarsqMinfsq*MBarSq + (1.0-sigMbarsqMinfsq )*MinfSq; // max(MBarSq,MinfSq)
  const CFreal mZero           = std::sqrt( (1-MathFunctions::sigmoid (1.0,sig2,Ksig))*1.0 + MathFunctions::sigmoid(1.0,sig2,Ksig)*sig2); //sqrt(min(1,max(MBarSq,MinfSq)))
  cf_assert(mZero <= 1.0);

  const CFreal fa = mZero * (2.0-mZero);
  m_fa = fa;

  const CFreal M4Plus  = (std::abs(ML) >= 1.0) ? this->mach1Plus(ML) : this->mach2Plus(ML)*(1.0 - 16.*beta*this->mach2Min(ML));
  const CFreal M4Minus = (std::abs(MR) >= 1.0) ? this->mach1Min(MR)  : this->mach2Min(MR)*(1.0 + 16.*beta*this->mach2Plus(MR));
  const CFreal mP      = -(this->m_coeffKp) * MathFunctions::sigmoid(1.0 - this->m_coeffSigma*MBarSq,0.0,Ksig)*(pR-pL)/(rho12*a12*a12);
  const CFreal M12     =  M4Plus + M4Minus + mP;
  
  const CFreal rhostar = MathFunctions::sigmoid(M12,0.0,Ksig)*rhoL + (1.0-MathFunctions::sigmoid(M12,0.0,Ksig))*rhoR;
  const CFreal mdot12  = M12*a12*rhostar;
  this->m_mflux12      = mdot12;
  
  const CFreal aCritL  = std::sqrt(2.0*(gammaL-1.0)/(gammaL+1.0)*HL);
  const CFreal aCritR  = std::sqrt(2.0*(gammaR-1.0)/(gammaR+1.0)*HR);
  
  const CFreal asigL   = MathFunctions::sigmoid(aCritL,qnL,Ksig)*aCritL + (1.0 - MathFunctions::sigmoid(aCritL,qnL,Ksig))*qnL;
  const CFreal asigR   = MathFunctions::sigmoid(aCritR,-qnR,Ksig)*aCritR - (1.0 - MathFunctions::sigmoid(aCritR,-qnR,Ksig))*qnR;
  
  const CFreal ahatL   = aCritL*aCritL/std::max(aCritL,qnL); 
  const CFreal ahatR   = aCritR*aCritR/std::max(aCritR,-qnR); 
  
  const CFreal sigmoid = MathFunctions::sigmoid(mdot12,0.0,Ksig);
  const CFreal alpha   = (3.0/16.0) * (-4.0 + 5.0*fa*fa);

  const CFreal P5Plus = (std::abs(ML) >= 1.0) ? 
    this->mach1Plus(ML)/ML :
    this->mach2Plus(ML)*((2.0-ML)-16.*alpha*ML*this->mach2Min(ML));
  m_P5Plus = P5Plus;

  const CFreal P5Minus = (std::abs(MR) >= 1.0) ? 
    this->mach1Min(MR)/MR :
    this->mach2Min(MR)*((-2.0-MR)+16.*alpha*MR*this->mach2Plus(MR));
  m_P5Minus = P5Minus;

  // new pressure interface for consistency
  const CFreal pu = 0.5*this->m_coeffKu*P5Plus*P5Minus*rho12*fa*a12*(qnR-qnL);

  this->m_p12 = P5Plus*pL + P5Minus*pR + pu;

  const CFreal drho12dVar   = 0.5*(m_drhoLdVar+ m_drhoRdVar);
  const CFreal drhostardVar = MathFunctions::sigmoid(M12,0,Ksig)*m_drhoLdVar + (1.0 - MathFunctions::sigmoid(M12,0.0,Ksig))*m_drhoRdVar;
  
  const CFreal daCritLdVar  = std::sqrt((gammaL-1.0)/(2.0*HL*(gammaL+1.0)))*m_dhLdVar;
  const CFreal daCritRdVar  = std::sqrt((gammaR-1.0)/(2.0*HR*(gammaR+1.0)))*m_dhRdVar;
    
  const CFreal dasigLdVar   = MathFunctions::sigmoid(aCritL,qnL,Ksig)*daCritLdVar + (1.0 - MathFunctions::sigmoid(aCritL,qnL,Ksig))*m_dqnLdVar;
  const CFreal dasigRdVar   = MathFunctions::sigmoid(aCritR,-qnR,Ksig)*daCritRdVar - (1.0 - MathFunctions::sigmoid(aCritR,-qnR,Ksig))*m_dqnRdVar;
    
  /// da12dVar ---------------------------------------------
  const CFreal da12dVar     = (1.0 - MathFunctions::sigmoid(ahatL,ahatR,Ksig))
                                *(2.0*aCritL/asigL*daCritLdVar - aCritL*aCritL/(asigL*asigL)*dasigLdVar)
                              + MathFunctions::sigmoid(ahatL,ahatR,Ksig)
                                *(2.0*aCritR/asigR*daCritRdVar - aCritR*aCritR/(asigR*asigR)*dasigRdVar);
  
  const CFreal dMLdVar      = 1.0/a12*m_dqnLdVar - qnL/(a12*a12)*da12dVar;
  const CFreal dMRdVar      = 1.0/a12*m_dqnRdVar - qnR/(a12*a12)*da12dVar;
  
  const CFreal dM4PLusdVar  = (std::abs(ML)>=1.0) ? 0.5*(1. + MathFunctions::sign(ML))*dMLdVar : (0.5*(ML+1.) + 4.*beta*ML*(ML*ML-1.))*dMLdVar;
  const CFreal dM4MinusdVar = (std::abs(MR)>=1.0) ? 0.5*(1. - MathFunctions::sign(MR))*dMRdVar : -(0.5*(MR-1.) + 4.*beta*MR*(MR*MR-1.))*dMRdVar;
  
  const CFreal dMBarSqdVar = ML*dMLdVar+MR*dMRdVar;
  const CFreal dmZerodVar  = 0.5/mZero*sigMbarsqMinfsq*MathFunctions::sigmoid(1.0,sig2,Ksig)*dMBarSqdVar;
  const CFreal dfadVar     = 2.0*(1.0-mZero)*dmZerodVar;  
  
  const CFreal dMpdVar     = -(this->m_coeffKp)*MathFunctions::sigmoid(1-(this->m_coeffSigma)*MBarSq,0.,Ksig)*(
                                        (m_dpRdVar-m_dpLdVar)/(rho12*a12*a12)
                                        -(pR-pL)/(rho12*rho12*a12*a12)*drho12dVar
                                        -2.0*(pR-pL)/(rho12*a12*a12*a12)*da12dVar);
  /// dM12dVar ---------------------------------------------
  const CFreal dM12dVar    = dM4PLusdVar + dM4MinusdVar + dMpdVar;
  
  const CFreal dmdot12dVar = dM12dVar*a12*rhostar + M12*da12dVar*rhostar + M12*a12*drhostardVar;
  
  const CFreal dalphadVar  = 15.0/8.0*fa*dfadVar;

  const CFreal dP5PlusdVar = (std::abs(ML) >= 1.0 ) ? 0. :
                            0.5*(10.0*alpha*ML*ML*ML*ML-(1.5+12.0*alpha)*ML*ML+1.5+2.0*alpha)*dMLdVar 
                            + ML*(ML*ML-1)*(ML*ML-1)*dalphadVar;
  const CFreal dP5MinusdVar = (std::abs(MR) >=1.0 ) ? 0. :
                            -0.5*(10.0*alpha*MR*MR*MR*MR-(1.5+12.0*alpha)*MR*MR+1.5+2.0*alpha)*dMRdVar 
                            - MR*(MR*MR-1)*(MR*MR-1)*dalphadVar;

  const CFreal dpudVar = 0.5*this->m_coeffKu*(
                       dP5PlusdVar*P5Minus*rho12*fa*a12*(qnR-qnL)
                      +P5Plus*dP5MinusdVar*rho12*fa*a12*(qnR-qnL)
                      +P5Plus*P5Minus*drho12dVar*fa*a12*(qnR-qnL)
                      +P5Plus*P5Minus*rho12*dfadVar*a12*(qnR-qnL)
                      +P5Plus*P5Minus*rho12*fa*da12dVar*(qnR-qnL)
                      +P5Plus*P5Minus*rho12*fa*da12dVar*(m_dqnRdVar-m_dqnLdVar));

  /// dp12dVar ----------------------------------------------
  const CFreal dp12dVar = dP5PlusdVar*pL + P5Plus*m_dpLdVar + dP5MinusdVar*pR + P5Minus*m_dpRdVar + dpudVar;

  // JacobMatrix(0,iVar) = dmdot12dVar; //dmdot12dVar*1+ mdot12*0 + 0
  // for (CFuint iDim = 0; iDim < nbDim; iDim++)
  // {
  //   JacobMatrix(iDim+1,iVar) = dmdot12dVar*(sigmoid*(*this->m_lData)[UPDATEVAR::PTERM::VX+iDim] + (1.0-sigmoid)*(*this->m_rData)[UPDATEVAR::PTERM::VX+iDim]) 
  //               + mdot12*(sigmoid*m_dVLdVar[iDim] + (1.0-sigmoid)*m_dVRdVar[iDim]) + dp12dVar*normal[iDim];    //Final result
  // }
  // JacobMatrix(nbEq-1,iVar) = dmdot12dVar*( sigmoid*HL+(1.0-sigmoid)*HR ) + mdot12*( sigmoid*m_dhLdVar+(1.0-sigmoid)*m_dhRdVar );
 
  JacobMatrix(0,iVar) = dmdot12dVar; //dmdot12dVar*1+ mdot12*0 + 0
  JacobMatrix(1,iVar) = dmdot12dVar*(sigmoid*(*this->m_lData)[UPDATEVAR::PTERM::VX] + (1.0-sigmoid)*(*this->m_rData)[UPDATEVAR::PTERM::VX]) 
                + mdot12*(sigmoid*m_duLdVar + (1.0-sigmoid)*m_duRdVar) + dp12dVar*normal[0];
  JacobMatrix(2,iVar) = dmdot12dVar*(sigmoid*(*this->m_lData)[UPDATEVAR::PTERM::VY] + (1.0-sigmoid)*(*this->m_rData)[UPDATEVAR::PTERM::VY]) 
                + mdot12*(sigmoid*m_dvLdVar + (1.0-sigmoid)*m_dvRdVar) + dp12dVar*normal[1];
  if (nbDim==3){
  JacobMatrix(3,iVar) = dmdot12dVar*(sigmoid*(*this->m_lData)[UPDATEVAR::PTERM::VZ] + (1.0-sigmoid)*(*this->m_rData)[UPDATEVAR::PTERM::VZ]) 
                + mdot12*(sigmoid*m_dwLdVar + (1.0-sigmoid)*m_dwRdVar) + dp12dVar*normal[2];
  }
  JacobMatrix(nbEq-1,iVar) = dmdot12dVar*( sigmoid*HL+(1.0-sigmoid)*HR ) + mdot12*( sigmoid*m_dhLdVar+(1.0-sigmoid)*m_dhRdVar );

  CFLog(VERBOSE," AUSMPlusUpFlux::ComputedFluxdVar  END \n");

}

/////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dFdP(CFuint side, CFuint iVar, RealMatrix& JacobMatrix)
{
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::dFdP  START\n");
// Update var : (p,u,v,w,T)
// dudP = dvdP = dwdP = 0 => dqndP = 0  
// H = E + p/rho => H = gamma/(gamma-1)Rgas*T/Mmass + V^2/2 => dHdP = 0
// rho = p*M/(R*T) => drhodP = M*p/(R*TS).
  const CFreal Mmass = 28.965338E-3; //molecular mass, assuming current fluid is air
  const CFreal Rgas  = 8.3145; //universal gas constant [J/mol/K] taken from Wolfram Alpha
  const CFreal TL    = (*this->m_lData)[UPDATEVAR::PTERM::T];
  const CFreal TR    = (*this->m_rData)[UPDATEVAR::PTERM::T];
  m_dqnLdVar  = 0.;
  m_dqnRdVar  = 0.;
  m_dhLdVar   = 0.;
  m_dhRdVar   = 0.;
  m_drhoLdVar = (side == LEFT) ? Mmass/(Rgas*TL) : 0.;
  m_drhoRdVar = (side == LEFT) ? 0. : Mmass/(Rgas*TR);
  m_dpLdVar   = (side == LEFT) ? 1. : 0.;
  m_dpRdVar   = (side == LEFT) ? 0. : 1.;
  // m_dVLdVar   = 0.;
  // m_dVRdVar   = 0.;
  m_duRdVar = 0.;
  m_duLdVar = 0.;
  m_dvRdVar = 0.;
  m_dvLdVar = 0.;
  m_dwRdVar = 0.;
  m_dwLdVar = 0.;
  ComputedFluxdVar(iVar,JacobMatrix);
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::dFdP  END\n"); 
}
 
//////////////////////////////////////////////////////////////////////////////
   
template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dFdU(CFuint side, CFuint iVar, RealMatrix& JacobMatrix)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::dFdU  START\n");  
// Update var : (p,u,v,w,T)
// dudu= 1.; dvdu = dwdu = 0 => dqndu = nx  
// H = E + p/rho => H = R*T*gamma/(M*(gamma-1) + V^2/2 => dHdu = u
// rho = p*M/(R*T) => drhodu =0.
  const RealVector& normal = this->getMethodData().getUnitNormal();
  m_drhoLdVar = 0.;
  m_drhoRdVar  = 0.;
  m_dpLdVar    = 0.;
  m_dpRdVar    = 0.;
  m_dqnLdVar   = (side == LEFT) ? normal[0] : 0.;
  m_dqnRdVar   = (side == LEFT) ? 0. : normal[0];
  m_dhLdVar    = (side == LEFT) ?(*this->m_lData)[UPDATEVAR::PTERM::VX]: 0.;
  m_dhRdVar    = (side == LEFT) ? 0. : (*this->m_rData)[UPDATEVAR::PTERM::VX];
  // m_dVLdVar    = 0.;
  // m_dVRdVar    = 0.; 
  // m_dVLdVar[0] = (side == LEFT) ? 1. : 0.;
  // m_dVRdVar[0] = (side == LEFT) ? 0. : 1.;
  m_duLdVar = (side == LEFT) ? 1. : 0.;
  m_duRdVar = (side == LEFT) ? 0. : 1.;
  m_dvLdVar = 0.;
  m_dvRdVar = 0.;
  m_dwLdVar = 0.;
  m_dwRdVar = 0.;
  ComputedFluxdVar(iVar,JacobMatrix);
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::dFdU  END\n");  
}

//////////////////////////////////////////////////////////////////////////////
   
template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dFdV(CFuint side, CFuint iVar, RealMatrix& JacobMatrix)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools;
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::dFdV  START\n");  
// Update var : (p,u,v,w,T)
// dvdv= 1.; dudv = dwdv = 0 => dqndv = ny  
// H = E + p/rho => H = R*T*gamma/(M*(gamma-1) + V^2/2 => dHdv = v
// rho = p*M/(R*T) => drhodu =0.
  const RealVector& normal = this->getMethodData().getUnitNormal();
  m_drhoLdVar  = 0.;
  m_drhoRdVar  = 0.;
  m_dpLdVar    = 0.;
  m_dpRdVar    = 0.;
  m_dqnLdVar   = (side == LEFT) ? normal[1]: 0.;
  m_dqnRdVar   = (side == LEFT) ? 0. : normal[1];
  m_dhLdVar    = (side == LEFT) ?(*this->m_lData)[UPDATEVAR::PTERM::VY]: 0.;
  m_dhRdVar    = (side == LEFT) ? 0. : (*this->m_rData)[UPDATEVAR::PTERM::VY];
  // m_dVLdVar    = 0.;
  // m_dVRdVar    = 0.; 
  // m_dVLdVar[1] = (side == LEFT) ? 1. : 0.;
  // m_dVRdVar[1] = (side == LEFT) ? 0. : 1.;
  m_duLdVar = 0.;
  m_duRdVar = 0.;
  m_dvLdVar = (side == LEFT) ? 1. : 0.;
  m_dvRdVar = (side == LEFT) ? 0. : 1.;
  m_dwLdVar = 0.;
  m_dwRdVar = 0.;
  ComputedFluxdVar(iVar,JacobMatrix);
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::dFdV  END\n");  
}

//////////////////////////////////////////////////////////////////////////////
  
template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dFdW(CFuint side, CFuint iVar, RealMatrix& JacobMatrix)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::dFdW  START\n");  
// Update var : (p,u,v,w,T)
// dwdw= 1.; dudw = dvdw = 0 => dqndw = nz  
// H = E + p/rho => H = R*T*gamma/(M*(gamma-1) + V^2/2 => dHdv = w
// rho = p*M/(R*T) => drhodu =0.
  const RealVector& normal = this->getMethodData().getUnitNormal();
  m_drhoLdVar  = 0.;
  m_drhoRdVar  = 0.;
  m_dpLdVar    = 0.;
  m_dpRdVar    = 0.;
  m_dqnLdVar   = (side == LEFT) ? normal[2] : 0.;
  m_dqnRdVar   = (side == LEFT) ? 0. : normal[2];
  m_dhLdVar    = (side == LEFT) ?(*this->m_lData)[UPDATEVAR::PTERM::VZ]: 0.;
  m_dhRdVar    = (side == LEFT) ? 0. : (*this->m_rData)[UPDATEVAR::PTERM::VZ];
  // m_dVLdVar    = 0.;
  // m_dVRdVar    = 0.; 
  // m_dVLdVar[2] = (side == LEFT) ? 1. : 0.;
  // m_dVRdVar[2] = (side == LEFT) ? 0. : 1.;
  m_duLdVar = 0.;
  m_duRdVar = 0.;
  m_dvLdVar = 0.;
  m_dvRdVar = 0.;
  m_dwLdVar = (side == LEFT) ? 1. : 0.;
  m_dwRdVar = (side == LEFT) ? 0. : 1.;
  ComputedFluxdVar(iVar,JacobMatrix);
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::dFdW  END\n");  
}
 
//////////////////////////////////////////////////////////////////////////////
   
template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dFdT(CFuint side, CFuint iVar, RealMatrix& JacobMatrix)
{
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::dFdT  START\n");
// Update var : (p,u,v,w,T)
// dudT = dvdT = dwdT = 0 => dqndT = 0  
// H = E + p/rho => H = gamma/(gamma-1)Rgas*T/Mmass + V^2/2 => dHdT = gamma/(gamma-1)Rgas*/Mmass
// rho = p*M/(R*T) => drhodT = -M*p/(R*T^2).
  const CFreal Mmass  = 28.965338E-3; //molecular mass, assuming current fluid is air
  const CFreal Rgas   = 8.3145; //universal gas constant [J/mol/K] taken from Wolfram Alpha
  const CFreal pL     = (*this->m_lData)[UPDATEVAR::PTERM::P];
  const CFreal pR     = (*this->m_rData)[UPDATEVAR::PTERM::P];
  const CFreal TL     = (*this->m_lData)[UPDATEVAR::PTERM::T];
  const CFreal TR     = (*this->m_rData)[UPDATEVAR::PTERM::T];
  const CFreal gammaL = (*this->m_lData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal gammaR = (*this->m_rData)[UPDATEVAR::PTERM::GAMMA];
  m_dqnLdVar  = 0.;
  m_dqnRdVar  = 0.;
  m_dhLdVar   = (side == LEFT) ? gammaL*Rgas/(Mmass*(gammaL-1.)) : 0.;
  m_dhRdVar   = (side == LEFT) ? 0. : gammaR*Rgas/(Mmass*(gammaR-1.));
  m_drhoLdVar = (side == LEFT) ? -Mmass*pL/(Rgas*TL*TL) : 0.;
  m_drhoRdVar = (side == LEFT) ? 0. : -Mmass*pR/(Rgas*TR*TR);
  m_dpLdVar   = 0.;
  m_dpRdVar   = 0.;
  // m_dVLdVar   = 0.;
  // m_dVRdVar   = 0.;
  m_duLdVar = 0.;
  m_duRdVar = 0.;
  m_dvLdVar = 0.;
  m_dvRdVar = 0.;
  m_dwLdVar = 0.;
  m_dwRdVar = 0.;  
  ComputedFluxdVar(iVar,JacobMatrix);
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::dFdT  END\n");  
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dFdK(CFuint side, CFuint iVar, RealMatrix& JacobMatrix)
{
  using namespace std;
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::dFdK  START\n");  
// Update var : ???
  m_dqnLdVar  = 0.;
  m_dqnRdVar  = 0.;
  m_dhLdVar   = 0.;
  m_dhRdVar   = 0.;
  m_drhoLdVar = 0.;
  m_drhoRdVar = 0.;
  m_dpLdVar   = 0.;
  m_dpRdVar   = 0.;
  // m_dVLdVar   = 0.;
  // m_dVRdVar   = 0.;
  m_duLdVar = 0.;
  m_duRdVar = 0.;
  m_dvLdVar = 0.;
  m_dvRdVar = 0.;
  m_dwLdVar = 0.;
  m_dwRdVar = 0.;     
  ComputedFluxdVar(iVar,JacobMatrix);
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::dFdK  END\n");  
}
 
//////////////////////////////////////////////////////////////////////////////
      
template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dFdRho(CFuint side, CFuint iVar, RealMatrix& JacobMatrix)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::dFdRho  START\n");  
// Update var : (rho,rhou,rhov,rhow,rhoE)
// E        = p/(rho*gamma-1) + V^2/2 => 
// p        = (gamma -1 )(rhoE - 0.5(rhoV)^2/rho) 
// dpdrho    = 0.5(gamma -1)V^2;
// u        = rhou/rho  
// dudrho   = -rhou/rho^2 
// dqndrho = -(unx+vny+wnz)/rho = -qn/rho
// H        = E + p/rho => 
// H        = gamma*rhoE/rho - 0.5*(gamma-1)*(rhoV)^2/rho^2 
// dHdrho   = -gamma*rhoE/rho^2 +(gamma-1)(rhou^2+rhov^2+rhow^2)/rho^3
  const CFuint nbDim  = PhysicalModelStack::getActive()->getDim();
  const CFreal gammaL = (*this->m_lData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal gammaR = (*this->m_rData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal rhoL   = (*this->m_lData)[UPDATEVAR::PTERM::RHO];
  const CFreal rhoR   = (*this->m_rData)[UPDATEVAR::PTERM::RHO];
  const CFreal EL     = (*this->m_lData)[UPDATEVAR::PTERM::E];
  const CFreal ER     = (*this->m_rData)[UPDATEVAR::PTERM::E];
  const CFreal qnL    = this->m_unL;
  const CFreal qnR    = this->m_unR;

  m_dqnLdVar  = (side == LEFT) ? -qnL/rhoL : 0.;
  m_dqnRdVar  = (side == LEFT) ? 0. : -qnR/rhoR;

  CFreal VLsq = 0.;
  CFreal VRsq = 0.;
  for (CFuint it = 0; it < nbDim ;it++)
    {
      VLsq = VLsq + (*this->m_lData)[UPDATEVAR::PTERM::VX+it]*(*this->m_lData)[UPDATEVAR::PTERM::VX+it]; // 2D : uL*uL+vL*vL  3D : uL*uL+vL*vL+wL*wL
      VRsq = VRsq + (*this->m_rData)[UPDATEVAR::PTERM::VX+it]*(*this->m_rData)[UPDATEVAR::PTERM::VX+it]; // 2D : uR*uR+vR*vR  3D : uR*uR+vR*vR+wR*wR
    }
  m_dhLdVar   = (side == LEFT) ? -gammaL*EL/rhoL + (gammaL-1.)*VLsq/rhoL : 0.;
  m_dhRdVar   = (side == LEFT) ? 0. :-gammaR*ER/rhoR + (gammaR-1.)*VRsq/rhoR;
  m_drhoLdVar = (side == LEFT) ? 1. : 0.;
  m_drhoRdVar = (side == LEFT) ? 0. : 1.;
  m_dpLdVar   = (side == LEFT) ? 0.5*(gammaL-1.)*VLsq : 0.;
  m_dpRdVar   = (side == LEFT) ? 0. : 0.5*(gammaR-1.)*VRsq;

  // for (CFuint it = 0; it < nbDim ;it++)
  //   {
  //     m_dVLdVar[it]   = (side == LEFT) ? -(*this->m_lData)[UPDATEVAR::PTERM::VX+it]/rhoL : 0.;
  //     m_dVRdVar[it]   = (side == LEFT) ? 0. : -(*this->m_rData)[UPDATEVAR::PTERM::VX+it]/rhoR;
  //   }
  m_duLdVar = (side == LEFT) ? -(*this->m_lData)[UPDATEVAR::PTERM::VX]/rhoL : 0.;
  m_duRdVar = (side == LEFT) ? 0. : -(*this->m_rData)[UPDATEVAR::PTERM::VX]/rhoR;
  m_dvLdVar = (side == LEFT) ? -(*this->m_lData)[UPDATEVAR::PTERM::VY]/rhoL : 0.;
  m_dvRdVar = (side == LEFT) ? 0. : -(*this->m_rData)[UPDATEVAR::PTERM::VY]/rhoR;
  if ( PhysicalModelStack::getActive()->getDim()==3){
  m_dwLdVar = (side == LEFT) ? -(*this->m_lData)[UPDATEVAR::PTERM::VZ]/rhoL : 0.;
  m_dwRdVar = (side == LEFT) ? 0. : -(*this->m_rData)[UPDATEVAR::PTERM::VZ]/rhoR;
  }
  ComputedFluxdVar(iVar,JacobMatrix);
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::dFdRho  END\n");  

}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dFdRhoU(CFuint side, CFuint iVar, RealMatrix& JacobMatrix)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::dFdRhoU  START\n");  
// Update var : (rho,rhou,rhov,rhow,rhoE)
// E = p/(rho*gamma-1) + V^2/2  
// p = (gamma -1 )(rhoE - 0.5(rhoV)^2/rho) 
// dprhou = -(gamma -1)u;
// u = rhou/rho => dwdrhou = 1/rho => dqndrhou = nx/rho
// H = E + p/rho
// H = gamma*rhoE/rho - 0.5*(gamma-1)*(rhoV)^2/rho^2 
// dHdrhou = -(gamma-1)u/rho;
  const RealVector& normal = this->getMethodData().getUnitNormal();
  const CFreal rhoL   = (*this->m_lData)[UPDATEVAR::PTERM::RHO];
  const CFreal rhoR   = (*this->m_rData)[UPDATEVAR::PTERM::RHO];
  const CFreal gammaL = (*this->m_lData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal gammaR = (*this->m_rData)[UPDATEVAR::PTERM::GAMMA];
  m_drhoLdVar  = 0.;
  m_drhoRdVar  = 0.;
  m_dqnLdVar   = (side == LEFT) ? normal[0]/rhoL: 0.;
  m_dqnRdVar   = (side == LEFT) ? 0. : normal[0]/rhoR;
  m_dhLdVar    = (side == LEFT) ? -(gammaL-1.)*(*this->m_lData)[UPDATEVAR::PTERM::VX]/rhoL: 0.;
  m_dhRdVar    = (side == LEFT) ? 0 : -(gammaR-1.)*(*this->m_rData)[UPDATEVAR::PTERM::VX]/rhoR;
  m_dpLdVar    = (side == LEFT) ? -(gammaL-1.)*(*this->m_lData)[UPDATEVAR::PTERM::VX]: 0.;
  m_dpRdVar    = (side == LEFT) ? 0. : -(gammaR-1.)*(*this->m_rData)[UPDATEVAR::PTERM::VX];
  // m_dVLdVar    = 0.;
  // m_dVRdVar    = 0.;  
  // m_dVLdVar[0] = (side == LEFT) ? 1/rhoL : 0.;
  // m_dVRdVar[0] = (side == LEFT) ? 0. : 1/rhoR;
  m_duLdVar = (side == LEFT) ? 1/rhoL : 0.;
  m_duRdVar = (side == LEFT) ? 0. : 1/rhoR;
  m_dvLdVar = 0.;
  m_dvRdVar = 0.;
  m_dwLdVar = 0.;
  m_dwRdVar = 0.; 
  ComputedFluxdVar(iVar,JacobMatrix);
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::dFdRhoU  END\n");  
}
 
//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dFdRhoV(CFuint side, CFuint iVar, RealMatrix& JacobMatrix)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::dFdRhoV  START\n");  
// Update var : (rho,rhou,rhov,rhow,rhoE)
// E = p/(rho*gamma-1) + V^2/2 => p = (gamma -1 )(rhoE - 0.5(rhoV)^2/rho^2) => dprhov = -(gamma -1)v/rho;
// v = rhov/rho => dwdrhoc = 1/rho => dqndrhov = ny/rho
// H = E + p/rho => H = gamma*rhoE/rho - 0.5*(gamma-1)*(rhoV)^2/rho^2 => dHdrhov = -(gamma-1)v/rho
  const RealVector& normal = this->getMethodData().getUnitNormal();
  const CFreal rhoL   = (*this->m_lData)[UPDATEVAR::PTERM::RHO];
  const CFreal rhoR   = (*this->m_rData)[UPDATEVAR::PTERM::RHO];
  const CFreal gammaL = (*this->m_lData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal gammaR = (*this->m_rData)[UPDATEVAR::PTERM::GAMMA];
  m_drhoLdVar  = 0.;
  m_drhoRdVar  = 0.;
  m_dqnLdVar   = (side == LEFT) ? normal[1]/rhoL: 0.;
  m_dqnRdVar   = (side == LEFT) ? 0. : normal[1]/rhoR;
  m_dhLdVar    = (side == LEFT) ? -(gammaL-1.)*(*this->m_lData)[UPDATEVAR::PTERM::VY]/rhoL: 0.;
  m_dhRdVar    = (side == LEFT) ? 0 : -(gammaR-1.)*(*this->m_rData)[UPDATEVAR::PTERM::VY]/rhoR;
  m_dpLdVar    = (side == LEFT) ? -(gammaL-1.)*(*this->m_lData)[UPDATEVAR::PTERM::VY]: 0.;
  m_dpRdVar    = (side == LEFT) ? 0. : -(gammaR-1.)*(*this->m_rData)[UPDATEVAR::PTERM::VY];
  // m_dVLdVar    = 0.;
  // m_dVRdVar    = 0.;  
  // m_dVLdVar[1] = (side == LEFT) ? 1/rhoL : 0.;
  // m_dVRdVar[1] = (side == LEFT) ? 0. : 1/rhoR;
  m_duLdVar = 0.;
  m_duRdVar = 0.;
  m_dvLdVar = (side == LEFT) ? 1/rhoL : 0.;
  m_dvRdVar = (side == LEFT) ? 0. : 1/rhoR;
  m_dwLdVar = 0.;
  m_dwRdVar = 0.;  
  ComputedFluxdVar(iVar,JacobMatrix);
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::dFdRhoV  END\n");  
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dFdRhoW(CFuint side, CFuint iVar, RealMatrix& JacobMatrix)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::dFdRhoW  START\n");  
// Update var : (rho,rhou,rhov,rhow,rhoE)
// E = p/(rho*gamma-1) + V^2/2 => p = (gamma -1 )(rhoE - 0.5(rhoV)^2/rho) => dprhow = -(gamma -1)w;
// w = rhoW/rho => dwdrhoW = 1/rho => dqndrhoW = nz/rho
// H = E + p/rho =
// H = gamma*rhoE/rho - 0.5*(gamma-1)*(rhoV)^2/rho^2 
// dHdrhow = -(gamma-1)w/rho
  const RealVector& normal = this->getMethodData().getUnitNormal();
  const CFreal rhoL   = (*this->m_lData)[UPDATEVAR::PTERM::RHO];
  const CFreal rhoR   = (*this->m_rData)[UPDATEVAR::PTERM::RHO];
  const CFreal gammaL = (*this->m_lData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal gammaR = (*this->m_rData)[UPDATEVAR::PTERM::GAMMA];
  m_drhoLdVar  = 0.;
  m_drhoRdVar  = 0.;
  m_dqnLdVar   = (side == LEFT) ? normal[2]/rhoL: 0.;
  m_dqnRdVar   = (side == LEFT) ? 0. : normal[2]/rhoR;
  m_dhLdVar    = (side == LEFT) ? -(gammaL-1.)*(*this->m_lData)[UPDATEVAR::PTERM::VZ]/rhoL: 0.;
  m_dhRdVar    = (side == LEFT) ? 0 : -(gammaR-1.)*(*this->m_rData)[UPDATEVAR::PTERM::VZ]/rhoR;
  m_dpLdVar    = (side == LEFT) ? -(gammaL-1.)*(*this->m_lData)[UPDATEVAR::PTERM::VZ]: 0.;
  m_dpRdVar    = (side == LEFT) ? 0. : -(gammaR-1.)*(*this->m_rData)[UPDATEVAR::PTERM::VZ];
  // m_dVLdVar    = 0.;
  // m_dVRdVar    = 0.;  
  // m_dVLdVar[2] = (side == LEFT) ? 1/rhoL : 0.;
  // m_dVRdVar[2] = (side == LEFT) ? 0. : 1/rhoR;
  m_duLdVar = 0.;
  m_duRdVar = 0.;
  m_dvLdVar = 0.;
  m_dvRdVar = 0.;  
  m_dwLdVar = (side == LEFT) ? 1/rhoL : 0.;
  m_dwRdVar = (side == LEFT) ? 0. : 1/rhoR;
  ComputedFluxdVar(iVar,JacobMatrix);
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::dFdRhoW  END\n");  
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::dFdRhoE(CFuint side, CFuint iVar, RealMatrix& JacobMatrix)
{
  using namespace std;
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::dFdRhoE  START\n");  
// Update var : (rho,rhou,rhov,rhow,rhoE)
// E = p/(rho*gamma-1) + V^2/2 
// p = (gamma -1 )(rhoE - 0.5(rhoV)^2/rho) 
// dprhoE = gamma-1;
// u = rhou/rho dudrhoE = 0. dqndrhoE = 0
// H = E + p/rho 
// H = gamma*rhoE/rho - 0.5*(gamma-1)*(rhoV)^2/rho^2 
// dHdrhoE = gamma/rho .
  const CFreal rhoL   = (*this->m_lData)[UPDATEVAR::PTERM::RHO];
  const CFreal rhoR   = (*this->m_rData)[UPDATEVAR::PTERM::RHO];
  const CFreal gammaL = (*this->m_lData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal gammaR = (*this->m_rData)[UPDATEVAR::PTERM::GAMMA];
  m_dqnLdVar  = 0.;
  m_dqnRdVar  = 0.;
  m_dhLdVar   = (side == LEFT) ? gammaL/rhoL : 0.;
  m_dhRdVar   = (side == LEFT) ? 0. : gammaR/rhoR;
  m_drhoLdVar = 0.;
  m_drhoRdVar = 0.;
  m_dpLdVar   = (side == LEFT) ? gammaL-1. : 0.;
  m_dpRdVar   = (side == LEFT) ? 0. : gammaR-1.;
  // m_dVLdVar   = 0.;
  // m_dVRdVar   = 0.;
  m_duLdVar = 0.;
  m_duRdVar = 0.;
  m_dvLdVar = 0.;
  m_dvRdVar = 0.;  
  m_dwLdVar = 0.;
  m_dwRdVar = 0.;    
  ComputedFluxdVar(iVar,JacobMatrix);
  CFLog(DEBUG_MIN,"AUSMPlusUpFlux::dFdRhoE  END\n");  
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::computeJacobianDPvt(CFuint side, RealMatrix& JacobMatrix)
{
  using namespace Framework;

  CFLog(VERBOSE,"AUSMPlusUpFlux::computeJacobianDPvt("<<side<<") START\n");  

  const CFuint nbEqs = PhysicalModelStack::getActive()->getNbEq();
  const CFuint nbDim = PhysicalModelStack::getActive()->getDim();

 // dFdP
  dFdP(side,0,JacobMatrix);
  //dFdU dFdV (dFdW)
  dFdU(side,1,JacobMatrix);
  dFdV(side,2,JacobMatrix);
  if (nbDim==3) {
    dFdW(side,3,JacobMatrix);
  }
  //dFdT
  dFdT(side,nbEqs-1,JacobMatrix);

  CFLog(VERBOSE,"AUSMPlusUpFlux::computeJacobianDPvt() END\n");
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::computeJacobianDCons(CFuint side, RealMatrix& JacobMatrix)
{
  using namespace Framework;

  CFLog(VERBOSE,"AUSMPlusUpFlux::computeJacobianDCons("<<side<<") START\n");  

  const CFuint nbEqs = PhysicalModelStack::getActive()->getNbEq();
  const CFuint nbDim = PhysicalModelStack::getActive()->getDim();

  // dFdRho
  dFdRho(side,0,JacobMatrix);
  //dFdRhoU dFdRhoV (dFdRhoW)
  dFdRhoU(side,1,JacobMatrix);
  dFdRhoV(side,2,JacobMatrix);
  if (nbDim==3) {
    dFdRhoW(side,3,JacobMatrix);
  }
  //dFdrhoE
  dFdRhoE(side,nbEqs-1,JacobMatrix);

  CFLog(VERBOSE,"AUSMPlusUpFlux::computeJacobianDCons() END\n");

}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::computeLeftJacobian()
{
  CFLog(VERBOSE,"AUSMPlusUpFlux::computeLeftJacobian() START\n");  
 
  const std::string upVar = this->getMethodData().getUpdateVarStr();

  RealMatrix& LeftJacobian = this->_lFluxJacobian;
  if (upVar == "Puvt" || upVar == "Pvt") {
    computeJacobianDPvt(LEFT,LeftJacobian);
  }
  if (upVar == "Cons") {
    computeJacobianDCons(LEFT,LeftJacobian);
  }
  
  CFLog(VERBOSE,"AUSMPlusUpFlux::computeLeftJacobian() END\n");  
}

// //////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::computeRightJacobian()
{
  CFLog(VERBOSE,"AUSMPlusUpFlux::computeRightJacobian() START\n");  
  
  const std::string upVar = this->getMethodData().getUpdateVarStr();
  RealMatrix& RightJacobian = this->_rFluxJacobian;

  if (upVar == "Puvt" || upVar == "Pvt") {
     computeJacobianDPvt(RIGHT,RightJacobian);
  }
  if (upVar == "Cons") {
    computeJacobianDCons(RIGHT,RightJacobian);
  }

  CFLog(VERBOSE,"AUSMPlusUpFlux::computeRightJacobian() END\n");  
}

//////////////////////////////////////////////////////////////////////////////

    } // namespace FiniteVolume

  } // namespace Numerics

} // namespace COOLFluiD

//////////////////////////////////////////////////////////////////////////////
