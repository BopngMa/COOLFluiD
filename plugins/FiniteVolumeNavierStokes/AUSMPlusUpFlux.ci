#include "Framework/EquationSetData.hh"
#include "Framework/PhysicalChemicalLibrary.hh"

//////////////////////////////////////////////////////////////////////////////

namespace COOLFluiD {

  namespace Numerics {

    namespace FiniteVolume {

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
AUSMPlusUpFlux<UPDATEVAR>::AUSMPlusUpFlux(const std::string& name) :
  AUSMFlux<UPDATEVAR>(name),
  m_fa(0.0),
  m_P5Plus(0.),
  m_P5Minus(0.)
{
  this->addConfigOptionsTo(this);
  m_coeffKu = 0.75;
  this->setParameter("coeffKu",&m_coeffKu);

  m_coeffKp = 0.25;
  this->setParameter("coeffKp",&m_coeffKp);

  m_coeffSigma = 1.0;
  this->setParameter("sigma",&m_coeffSigma);

  m_machInf = 0.;
  this->setParameter("machInf",&m_machInf);

  m_beta = 1./8.;
  this->setParameter("beta",&m_beta);
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
AUSMPlusUpFlux<UPDATEVAR>::~AUSMPlusUpFlux()
{
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::defineConfigOptions(Config::OptionList& options)
{
  options.template addConfigOption< CFreal >
    ("coeffKu","Coefficient for Ku.");
  options.template addConfigOption< CFreal >
    ("coeffKp","Way of computing the pressure.");
  options.template addConfigOption< CFreal >
    ("sigma","Coefficient for sigma.");
  options.template addConfigOption< CFreal >
    ("machInf","Free stream Mach number.");
  options.template addConfigOption< CFreal >
    ("beta"," -1/16 <= beta coefficient <= 1/2.");
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::setup()
{
  using namespace COOLFluiD::Framework;
 
  AUSMFlux<UPDATEVAR>::setup();

  const CFuint nbDim = PhysicalModelStack::getActive()->getDim();
  m_dVLdVar.resize(nbDim);
  m_dVRdVar.resize(nbDim);
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::computeMassFlux()
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  
  if (m_machInf <= 0.) {
    cout << "AUSMPlusUpFlux requires machInf > 0.!!: change your input file!!" << endl;
  }
  
  this->computeInterfaceSoundSpeed(); // m_a12
  
  // calculation of the Mach number for the left and the right states
  this->m_mL = this->m_unL/this->m_a12;
  this->m_mR = this->m_unR/this->m_a12;
  const CFreal mL = this->m_mL;
  const CFreal mR = this->m_mR;
  const CFreal mBarSq = (this->m_unL*this->m_unL + this->m_unR*this->m_unR) /
    (2.0*this->m_a12*this->m_a12);

  const CFreal mInf = correctMachInf(this->m_machInf);
  const CFreal mZero = std::sqrt(std::min(1.0, max(mBarSq,  mInf*mInf)));
  cf_assert(mZero <= 1.0);

  m_fa = mZero * (2.0-mZero);
  cf_assert(m_fa > 0.0);
   
  const CFreal M4Plus = (std::abs(mL) >= 1.0) ? 
    this->mach1Plus(mL) :
    this->mach2Plus(mL)*(1.0 - 16.*m_beta*this->mach2Min(mL));
  
  const CFreal M4Minus = (std::abs(mR) >= 1.0) ? 
    this->mach1Min(mR) :
    this->mach2Min(mR)*(1.0 + 16.*m_beta*this->mach2Plus(mR));
  
  const CFreal rhoL = (*this->m_lData)[UPDATEVAR::PTERM::RHO];
  const CFreal rhoR = (*this->m_rData)[UPDATEVAR::PTERM::RHO];
  const CFreal pL = (*this->m_lData)[UPDATEVAR::PTERM::P];
  const CFreal pR = (*this->m_rData)[UPDATEVAR::PTERM::P];
  const CFreal rhoa2 = 0.5*(rhoL + rhoR)*this->m_a12*this->m_a12;
  const CFreal mP = (-this->m_coeffKp/m_fa) * max(1.0 - this->m_coeffSigma*mBarSq, 0.0)*
    (pR-pL)/rhoa2;
  
  // calculation of the Mach number at the interface
  const CFreal m12 = M4Plus + M4Minus + mP;
  // calculation of the mass flux at the interface
  this->m_mflux12 = (m12 > 0.0) ? this->m_a12 * m12 * rhoL : this->m_a12 * m12 * rhoR;
}
      
//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::computePressureFlux()
{
  using namespace std;
  using namespace COOLFluiD::Framework;

  // here in AIAA 2003-4116 there is only "m_fa"
  const CFreal alpha = (3.0/16.0) * (-4.0 + 5.0*m_fa*m_fa);
  const CFreal mL = this->m_mL;
  const CFreal mR = this->m_mR;
  m_P5Plus = (std::abs(mL) >= 1.0) ? 
    this->mach1Plus(mL)/mL :
    this->mach2Plus(mL)*((2.0-mL)-16.*alpha*mL*this->mach2Min(mL));
  
  m_P5Minus = (std::abs(mR) >= 1.0) ? 
    this->mach1Min(mR)/mR :
    this->mach2Min(mR)*((-2.0-mR)+16.*alpha*mR*this->mach2Plus(mR));
  
  const CFreal rhoL = (*this->m_lData)[UPDATEVAR::PTERM::RHO];
  const CFreal rhoR = (*this->m_rData)[UPDATEVAR::PTERM::RHO];
  const CFreal pL   = (*this->m_lData)[UPDATEVAR::PTERM::P];
  const CFreal pR   = (*this->m_rData)[UPDATEVAR::PTERM::P];
  const CFreal pU   = -this->m_coeffKu * m_P5Plus * m_P5Minus *
    (rhoL + rhoR) * m_fa * this->m_a12*(this->m_unR-this->m_unL);
  
  // calculation of the pressure flux at the interface
  this->m_p12 = m_P5Plus*pL + m_P5Minus*pR + pU;
}
 
/////////////////////////////////////////////////////////////////////////////

template<class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::ComputedFluxdVar(CFreal *row)
{
  using namespace std;
  using namespace COOLFluiD::Framework;
  using namespace COOLFluiD::MathTools; //importing MathFunctions::sigmoidal and MathFunctions::sign functions
  CFLog(VERBOSE," AUSMPlusUpFlux::ComputedFluxdVar  START \n");

  // Getting state value
  const CFreal rhoL        = (*this->m_lData)[UPDATEVAR::PTERM::RHO];
  const CFreal rhoR        = (*this->m_rData)[UPDATEVAR::PTERM::RHO];
  const CFreal HL          = (*this->m_lData)[UPDATEVAR::PTERM::H];
  const CFreal HR          = (*this->m_rData)[UPDATEVAR::PTERM::H];
  const CFreal gammaL      = (*this->m_lData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal gammaR      = (*this->m_rData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal pL          = (*this->m_lData)[UPDATEVAR::PTERM::P];
  const CFreal pR          = (*this->m_rData)[UPDATEVAR::PTERM::P];
  const CFreal beta        = m_beta;
  const CFreal qnL         = this->m_unL;
  const CFreal qnR         = this->m_unR;
  const CFreal Ksig        = this->m_coeffSigmoid;
  const RealVector& normal = this->getMethodData().getUnitNormal();
  const CFuint nbDim       = PhysicalModelStack::getActive()->getDim();
  const CFuint nbEq        = PhysicalModelStack::getActive()->getNbEq();
  cf_assert(nbEq==nbDim+2); // Checking that the vector has the right size

  this->computeSoundSpeedForJacobian();
  const CFreal a12 = this->m_a12;

  const CFreal rho12  = 0.5*(rhoL + rhoR);
  this->m_mL          = this->m_unL/this->m_a12;
  this->m_mR          = this->m_unR/this->m_a12;
  const CFreal ML     = this->m_mL;
  const CFreal MR     = this->m_mR;

  const CFreal mInf            = correctMachInf(this->m_machInf);
  const CFreal MBarSq          = 0.5*(ML*ML+MR*MR);
  const CFreal MinfSq          = mInf*mInf;
  const CFreal sigMbarsqMinfsq = MathFunctions::sigmoid(MBarSq,MinfSq,Ksig);
  const CFreal sig2            = sigMbarsqMinfsq*MBarSq + (1.0-sigMbarsqMinfsq )*MinfSq; // max(MBarSq,MinfSq)
  const CFreal mZero           = std::sqrt( (1-MathFunctions::sigmoid (1.0,sig2,Ksig))*1.0 + MathFunctions::sigmoid(1.0,sig2,Ksig)*sig2); //sqrt(min(1,max(MBarSq,MinfSq)))
  cf_assert(mZero <= 1.0);

  const CFreal fa = mZero * (2.0-mZero);
  m_fa = fa;

  const CFreal M4Plus  = (std::abs(ML) >= 1.0) ? this->mach1Plus(ML) : this->mach2Plus(ML)*(1.0 - 16.*beta*this->mach2Min(ML));
  const CFreal M4Minus = (std::abs(MR) >= 1.0) ? this->mach1Min(MR)  : this->mach2Min(MR)*(1.0 + 16.*beta*this->mach2Plus(MR));
  const CFreal mP      = -(this->m_coeffKp) * MathFunctions::sigmoid(1.0 - this->m_coeffSigma*MBarSq,0.0,Ksig)*(pR-pL)/(rho12*a12*a12);
  const CFreal M12     =  M4Plus + M4Minus + mP;
  
  const CFreal rhostar = MathFunctions::sigmoid(M12,0.0,Ksig)*rhoL + (1.0-MathFunctions::sigmoid(M12,0.0,Ksig))*rhoR;
  const CFreal mdot12  = M12*a12*rhostar;
  this->m_mflux12      = mdot12;
  
  const CFreal aCritL  = std::sqrt(2.0*(gammaL-1.0)/(gammaL+1.0)*HL);
  const CFreal aCritR  = std::sqrt(2.0*(gammaR-1.0)/(gammaR+1.0)*HR);
  
  const CFreal asigL   = MathFunctions::sigmoid(aCritL,qnL,Ksig)*aCritL + (1.0 - MathFunctions::sigmoid(aCritL,qnL,Ksig))*qnL;
  const CFreal asigR   = MathFunctions::sigmoid(aCritR,-qnR,Ksig)*aCritR - (1.0 - MathFunctions::sigmoid(aCritR,-qnR,Ksig))*qnR;
  
  const CFreal ahatL   = aCritL*aCritL/std::max(aCritL,qnL); 
  const CFreal ahatR   = aCritR*aCritR/std::max(aCritR,-qnR); 
  
  const CFreal sigmoid = MathFunctions::sigmoid(mdot12,0.0,Ksig);
  const CFreal alpha   = (3.0/16.0) * (-4.0 + 5.0*fa*fa);

  const CFreal P5Plus = (std::abs(ML) >= 1.0) ? 
    this->mach1Plus(ML)/ML :
    this->mach2Plus(ML)*((2.0-ML)-16.*alpha*ML*this->mach2Min(ML));
  m_P5Plus = P5Plus;

  const CFreal P5Minus = (std::abs(MR) >= 1.0) ? 
    this->mach1Min(MR)/MR :
    this->mach2Min(MR)*((-2.0-MR)+16.*alpha*MR*this->mach2Plus(MR));
  m_P5Minus = P5Minus;

  // new pressure interface for consistency
  const CFreal pu = 0.5*this->m_coeffKu*P5Plus*P5Minus*rho12*fa*a12*(qnR-qnL);

  this->m_p12 = P5Plus*pL + P5Minus*pR + pu;

  const CFreal drho12dVar   = 0.5*(m_drhoLdVar+ m_drhoRdVar);
  const CFreal drhostardVar = MathFunctions::sigmoid(M12,0,Ksig)*m_drhoLdVar + (1.0 - MathFunctions::sigmoid(M12,0.0,Ksig))*m_drhoRdVar;
  
  const CFreal daCritLdVar  = std::sqrt((gammaL-1.0)/(2.0*HL*(gammaL+1.0)))*m_dhLdVar;
  const CFreal daCritRdVar  = std::sqrt((gammaR-1.0)/(2.0*HR*(gammaR+1.0)))*m_dhRdVar;
    
  const CFreal dasigLdVar   = MathFunctions::sigmoid(aCritL,qnL,Ksig)*daCritLdVar + (1.0 - MathFunctions::sigmoid(aCritL,qnL,Ksig))*m_dqnLdVar;
  const CFreal dasigRdVar   = MathFunctions::sigmoid(aCritR,-qnR,Ksig)*daCritRdVar - (1.0 - MathFunctions::sigmoid(aCritR,-qnR,Ksig))*m_dqnRdVar;
    
  /// da12dVar ---------------------------------------------
  const CFreal da12dVar     = (1.0 - MathFunctions::sigmoid(ahatL,ahatR,Ksig))
                                *(2.0*aCritL/asigL*daCritLdVar - aCritL*aCritL/(asigL*asigL)*dasigLdVar)
                              + MathFunctions::sigmoid(ahatL,ahatR,Ksig)
                                *(2.0*aCritR/asigR*daCritRdVar - aCritR*aCritR/(asigR*asigR)*dasigRdVar);
  
  const CFreal dMLdVar      = 1.0/a12*m_dqnLdVar - qnL/(a12*a12)*da12dVar;
  const CFreal dMRdVar      = 1.0/a12*m_dqnRdVar - qnR/(a12*a12)*da12dVar;
  
  const CFreal dM4PLusdVar  = (std::abs(ML)>=1.0) ? 0.5*(1. + MathFunctions::sign(ML))*dMLdVar : (0.5*(ML+1.) + 4.*beta*ML*(ML*ML-1.))*dMLdVar;
  const CFreal dM4MinusdVar = (std::abs(MR)>=1.0) ? 0.5*(1. - MathFunctions::sign(MR))*dMRdVar : -(0.5*(MR-1.) + 4.*beta*MR*(MR*MR-1.))*dMRdVar;
  
  const CFreal dMBarSqdVar = ML*dMLdVar+MR*dMRdVar;
  const CFreal dmZerodVar  = 0.5/mZero*sigMbarsqMinfsq*MathFunctions::sigmoid(1.0,sig2,Ksig)*dMBarSqdVar;
  const CFreal dfadVar     = 2.0*(1.0-mZero)*dmZerodVar;  
  
  const CFreal dMpdVar     = -(this->m_coeffKp)*MathFunctions::sigmoid(1-(this->m_coeffSigma)*MBarSq,0.,Ksig)*(
                                        (m_dpRdVar-m_dpLdVar)/(rho12*a12*a12)
                                        -(pR-pL)/(rho12*rho12*a12*a12)*drho12dVar
                                        -2.0*(pR-pL)/(rho12*a12*a12*a12)*da12dVar);
  /// dM12dVar ---------------------------------------------
  const CFreal dM12dVar    = dM4PLusdVar + dM4MinusdVar + dMpdVar;
  
  const CFreal dmdot12dVar = dM12dVar*a12*rhostar + M12*da12dVar*rhostar + M12*a12*drhostardVar;
  
  const CFreal dalphadVar  = 15.0/8.0*fa*dfadVar;

  const CFreal dP5PlusdVar = (std::abs(ML) >= 1.0 ) ? 0. :
                            0.5*(10.0*alpha*ML*ML*ML*ML-(1.5+12.0*alpha)*ML*ML+1.5+2.0*alpha)*dMLdVar 
                            + ML*(ML*ML-1)*(ML*ML-1)*dalphadVar;
  const CFreal dP5MinusdVar = (std::abs(MR) >=1.0 ) ? 0. :
                            -0.5*(10.0*alpha*MR*MR*MR*MR-(1.5+12.0*alpha)*MR*MR+1.5+2.0*alpha)*dMRdVar 
                            - MR*(MR*MR-1)*(MR*MR-1)*dalphadVar;

  const CFreal dpudVar = 0.5*this->m_coeffKu*(
                       dP5PlusdVar*P5Minus*rho12*fa*a12*(qnR-qnL)
                      +P5Plus*dP5MinusdVar*rho12*fa*a12*(qnR-qnL)
                      +P5Plus*P5Minus*drho12dVar*fa*a12*(qnR-qnL)
                      +P5Plus*P5Minus*rho12*dfadVar*a12*(qnR-qnL)
                      +P5Plus*P5Minus*rho12*fa*da12dVar*(qnR-qnL)
                      +P5Plus*P5Minus*rho12*fa*da12dVar*(m_dqnRdVar-m_dqnLdVar));

  /// dp12dVar ----------------------------------------------
  const CFreal dp12dVar = dP5PlusdVar*pL + P5Plus*m_dpLdVar + dP5MinusdVar*pR + P5Minus*m_dpRdVar + dpudVar;

  row[0] = dmdot12dVar; //dmdot12dVar*1+ mdot12*0 + 0
  for (CFuint iDim = 0; iDim < nbDim; iDim++)
  {
    row[iDim+1] = dmdot12dVar*(sigmoid*(*this->m_lData)[UPDATEVAR::PTERM::VX+iDim] + (1.0-sigmoid)*(*this->m_rData)[UPDATEVAR::PTERM::VX+iDim]) 
                + mdot12*(sigmoid*m_dVLdVar[iDim] + (1.0-sigmoid)*m_dVRdVar[iDim]) + dp12dVar*normal[iDim];    //Final result
  }
  row[nbEq-1] = dmdot12dVar*( sigmoid*HL+(1.0-sigmoid)*HR ) + mdot12*( sigmoid*m_dhLdVar+(1.0-sigmoid)*m_dhRdVar );
 
  CFLog(VERBOSE," AUSMPlusUpFlux::ComputedFluxdVar  END \n");

}

/////////////////////////////////////////////////////////////////////////////


template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::computeJacobianDPvt(CFuint side)
{
  using namespace Framework;

  CFLog(VERBOSE,"AUSMPlusUpFlux::computeJacobianDPvt("<<side<<") START\n");  

  const CFuint nbEqs = PhysicalModelStack::getActive()->getNbEq();
  const CFuint nbDim = PhysicalModelStack::getActive()->getDim();

  this->_tmpJacobMatrix = 0.;

 // dFdP
  const CFreal Mmass  = 28.965338E-3; //molecular mass, assuming current fluid is air
  const CFreal Rgas   = 8.3145; //universal gas constant [J/mol/K] taken from Wolfram Alpha
  const CFreal TL     = (*this->m_lData)[UPDATEVAR::PTERM::T];
  const CFreal TR     = (*this->m_rData)[UPDATEVAR::PTERM::T];
  
  m_dqnLdVar  = 0.;
  m_dqnRdVar  = 0.;
  m_dhLdVar   = 0.;
  m_dhRdVar   = 0.;
  m_drhoLdVar = (side == LEFT) ? Mmass/(Rgas*TL) : 0.;
  m_drhoRdVar = (side == LEFT) ? 0. : Mmass/(Rgas*TR);
  m_dpLdVar   = (side == LEFT) ? 1. : 0.;
  m_dpRdVar   = (side == LEFT) ? 0. : 1.;
  m_dVLdVar   = 0.;
  m_dVRdVar   = 0.;

  ComputedFluxdVar(&(this->_tmpJacobMatrix[0]));
  
  //dFdU dFdV (dFdW)
  const RealVector& normal = this->getMethodData().getUnitNormal();
  m_drhoLdVar = 0.;
  m_drhoRdVar = 0.;
  m_dpLdVar   = 0.;
  m_dpRdVar   = 0.;

  for (CFuint iDim = 0 ; iDim < nbDim ; iDim ++)
  {
    m_dqnLdVar      = (side == LEFT) ? normal[iDim] : 0.;
    m_dqnRdVar      = (side == LEFT) ? 0. : normal[iDim];
    m_dhLdVar       = (side == LEFT) ?(*this->m_lData)[UPDATEVAR::PTERM::VX+iDim]: 0.;
    m_dhRdVar       = (side == LEFT) ? 0. : (*this->m_rData)[UPDATEVAR::PTERM::VX+iDim];
    m_dVLdVar       = 0.;
    m_dVRdVar       = 0.; 
    m_dVLdVar[iDim] = (side == LEFT) ? 1. : 0.;
    m_dVRdVar[iDim] = (side == LEFT) ? 0. : 1.;

    ComputedFluxdVar(&(this->_tmpJacobMatrix[nbEqs*(1+iDim)]));
  }
  //dFdT
  const CFreal pL        = (*this->m_lData)[UPDATEVAR::PTERM::P];
  const CFreal pR        = (*this->m_rData)[UPDATEVAR::PTERM::P];
  const CFreal gammaL    = (*this->m_lData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal gammaR    = (*this->m_rData)[UPDATEVAR::PTERM::GAMMA];

  m_dqnLdVar  = 0.;
  m_dqnRdVar  = 0.;
  m_dhLdVar   = (side == LEFT) ? gammaL*Rgas/(Mmass*(gammaL-1.)) : 0.;
  m_dhRdVar   = (side == LEFT) ? 0. : gammaR*Rgas/(Mmass*(gammaR-1.));
  m_drhoLdVar = (side == LEFT) ? -Mmass*pL/(Rgas*TL*TL) : 0.;
  m_drhoRdVar = (side == LEFT) ? 0. : -Mmass*pR/(Rgas*TR*TR);
  m_dpLdVar   = 0.;
  m_dpRdVar   = 0.;
  m_dVLdVar   = 0.;
  m_dVRdVar   = 0.;   

  ComputedFluxdVar(&(this->_tmpJacobMatrix[nbEqs*(nbEqs-1)]));

  CFLog(VERBOSE,"AUSMPlusUpFlux::computeJacobianDPvt() END\n");
}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::computeJacobianDCons(CFuint side)
{
  using namespace Framework;

  CFLog(VERBOSE,"AUSMPlusUpFlux::computeJacobianDCons("<<side<<") START\n");  

  const CFuint nbEqs = PhysicalModelStack::getActive()->getNbEq();
  const CFuint nbDim = PhysicalModelStack::getActive()->getDim();
    
  this->_tmpJacobMatrix = 0.;

 // dFdRho
  const CFreal gammaL    = (*this->m_lData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal gammaR    = (*this->m_rData)[UPDATEVAR::PTERM::GAMMA];
  const CFreal rhoL      = (*this->m_lData)[UPDATEVAR::PTERM::RHO];
  const CFreal rhoR      = (*this->m_rData)[UPDATEVAR::PTERM::RHO];
  const CFreal EL        = (*this->m_lData)[UPDATEVAR::PTERM::E];
  const CFreal ER        = (*this->m_rData)[UPDATEVAR::PTERM::E];
  const CFreal qnL       = this->m_unL;
  const CFreal qnR       = this->m_unR;

  m_dqnLdVar  = (side == LEFT) ? -qnL/rhoL : 0.;
  m_dqnRdVar  = (side == LEFT) ? 0. : -qnR/rhoR;

  CFreal VLsq = 0.;
  CFreal VRsq = 0.;
  for (CFuint it = 0; it < nbDim ;it++)
    {
      VLsq = VLsq + (*this->m_lData)[UPDATEVAR::PTERM::VX+it]*(*this->m_lData)[UPDATEVAR::PTERM::VX+it]; // 2D : uL*uL+vL*vL  3D : uL*uL+vL*vL+wL*wL
      VRsq = VRsq + (*this->m_rData)[UPDATEVAR::PTERM::VX+it]*(*this->m_rData)[UPDATEVAR::PTERM::VX+it]; // 2D : uR*uR+vR*vR  3D : uR*uR+vR*vR+wR*wR
    }
  m_dhLdVar   = (side == LEFT) ? -gammaL*EL/rhoL + (gammaL-1.)*VLsq/rhoL : 0.;
  m_dhRdVar   = (side == LEFT) ? 0. :-gammaR*ER/rhoR + (gammaR-1.)*VRsq/rhoR;
  m_drhoLdVar = (side == LEFT) ? 1. : 0.;
  m_drhoRdVar = (side == LEFT) ? 0. : 1.;
  m_dpLdVar   = (side == LEFT) ? 0.5*(gammaL-1.)*VLsq : 0.;
  m_dpRdVar   = (side == LEFT) ? 0. : 0.5*(gammaR-1.)*VRsq;

  for (CFuint it = 0; it < nbDim ;it++)
    {
      m_dVLdVar[it]   = (side == LEFT) ? -(*this->m_lData)[UPDATEVAR::PTERM::VX+it]/rhoL : 0.;
      m_dVRdVar[it]   = (side == LEFT) ? 0. : -(*this->m_rData)[UPDATEVAR::PTERM::VX+it]/rhoR;
    }

  ComputedFluxdVar(&(this->_tmpJacobMatrix[0]));
  
  //dFdrhoU dFdrhoV (dFdrhoW)
  const RealVector& normal = this->getMethodData().getUnitNormal();
  m_drhoLdVar = 0.;
  m_drhoRdVar = 0.;

  for (CFuint iDim = 0 ; iDim < nbDim ; iDim ++)
  {
    m_dqnLdVar      = (side == LEFT) ? normal[iDim]/rhoL: 0.;
    m_dqnRdVar      = (side == LEFT) ? 0. : normal[iDim]/rhoR;
    m_dhLdVar       = (side == LEFT) ? -(gammaL-1.)*(*this->m_lData)[UPDATEVAR::PTERM::VX+iDim]/rhoL: 0.;
    m_dhRdVar       = (side == LEFT) ? 0 : -(gammaR-1.)*(*this->m_rData)[UPDATEVAR::PTERM::VX+iDim]/rhoR;
    m_dpLdVar       = (side == LEFT) ? -(gammaL-1.)*(*this->m_lData)[UPDATEVAR::PTERM::VX+iDim]: 0.;
    m_dpRdVar       = (side == LEFT) ? 0. : -(gammaR-1.)*(*this->m_rData)[UPDATEVAR::PTERM::VX+iDim];
    m_dVLdVar       = 0.;
    m_dVRdVar       = 0.;  
    m_dVLdVar[iDim] = (side == LEFT) ? 1/rhoL : 0.;
    m_dVRdVar[iDim] = (side == LEFT) ? 0. : 1/rhoR;
    ComputedFluxdVar(&(this->_tmpJacobMatrix[nbEqs*(1+iDim)]));
  }

  //dFdrhoE
  m_dqnLdVar  = 0.;
  m_dqnRdVar  = 0.;
  m_dhLdVar   = (side == LEFT) ? gammaL/rhoL : 0.;
  m_dhRdVar   = (side == LEFT) ? 0. : gammaR/rhoR;
  m_drhoLdVar = 0.;
  m_drhoRdVar = 0.;
  m_dpLdVar   = (side == LEFT) ? gammaL-1. : 0.;
  m_dpRdVar   = (side == LEFT) ? 0. : gammaR-1.;
  m_dVLdVar   = 0.;
  m_dVRdVar   = 0.;   

  ComputedFluxdVar(&(this->_tmpJacobMatrix[nbEqs*(nbEqs-1)]));

  CFLog(VERBOSE,"AUSMPlusUpFlux::computeJacobianDCons() END\n");

}

//////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::computeLeftJacobian()
{
  CFLog(VERBOSE,"AUSMPlusUpFlux::computeLeftJacobian() START\n");  
 
  const std::string upVar = this->getMethodData().getUpdateVarStr();
  if (upVar == "Puvt" || upVar == "Pvt") {
    computeJacobianDPvt(LEFT);
  }
  if (upVar == "Cons") {
    computeJacobianDCons(LEFT);
  }
  (this->_tmpJacobMatrix).transpose(this->_lFluxJacobian);
  
  CFLog(VERBOSE,"AUSMPlusUpFlux::computeLeftJacobian() END\n");  
}

// //////////////////////////////////////////////////////////////////////////////

template <class UPDATEVAR>
void AUSMPlusUpFlux<UPDATEVAR>::computeRightJacobian()
{
  CFLog(VERBOSE,"AUSMPlusUpFlux::computeRightJacobian() START\n");  
  
  const std::string upVar = this->getMethodData().getUpdateVarStr();
  if (upVar == "Puvt" || upVar == "Pvt") {
     computeJacobianDPvt(RIGHT);
  }
  if (upVar == "Cons") {
    computeJacobianDCons(RIGHT);
  }
  (this->_tmpJacobMatrix).transpose(this->_rFluxJacobian);

  CFLog(VERBOSE,"AUSMPlusUpFlux::computeRightJacobian() END\n");  
}

//////////////////////////////////////////////////////////////////////////////

    } // namespace FiniteVolume

  } // namespace Numerics

} // namespace COOLFluiD

//////////////////////////////////////////////////////////////////////////////
